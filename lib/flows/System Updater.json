[{"id":"fdedafb5b4235446","type":"group","z":"fe5f43f9.82396","name":"System Updater","style":{"stroke":"#6f2fa0","label":true,"color":"#9363b7"},"nodes":["f69b3ca.3ffe7c","ed0df5d5fb759f7b","2245a9a961f6a215","1227012782df8a0e","4f275fa1eca0e458","0584cedf39b8723a","ce0d4144ed5fdf9a","604d000ae234f177","a674def38f0c9d37","42a722f8accaab32","38735b09c743921a","c4f79b533903359f","7d74bf6cd8138ece","84d482c883a4a867","a62fd577f023f24d","4681dd71c58fc10d","322fd830eeaede98","be38cec0fa8511b4","c07c846829c39f05","357a8217f1c72be0","ca4bbbd0e0a22499","f5fbc0ae3593a8de","035ae4d8c7805872","f770e29b55017dcd"],"x":34,"y":39,"w":1392,"h":322},{"id":"f9586397.5973","type":"subflow","name":"Load Modules","info":"Useful utility functions used within various other functions\r\n### Functions\r\nLoaded into GlobalContext within the utils object , the environment variable\r\nENV_UTIL_OBJECT can be used to override the object name\r\n\r\n: round (number)     :  (value, precision)\r\n: TBC (string)       :  TBC\r\n\r\n### Outputs\r\n\r\n1. round\r\n: TBC (string)   : TBC\r\n: TBC (string)     : TBC\r\n\r\n### Details\r\n\r\n`TBC` TBC\r\n\r\n### References\r\n\r\n - Author - SK\r\n - Version - 1.0","category":"","in":[],"out":[],"env":[{"name":"MODULE_ID","type":"env","value":"MODULE_ID"}],"meta":{},"color":"#DDAA99","status":{"x":900,"y":300,"wires":[{"id":"4469c59cdb2428b0","port":0},{"id":"cdba6a1bd9ad79e5","port":0}]}},{"id":"7d7eee51.7878a8","type":"function","z":"f9586397.5973","d":true,"name":"hex2dec","func":"global.set('hex2dec', function(hexa) {\n    return parseInt(hexa, 16);\n}, 'memoryOnly');\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":720,"y":380,"wires":[[]]},{"id":"2012dbe6.92df34","type":"function","z":"f9586397.5973","d":true,"name":"hex2bin","func":"global.set('hex2bin', function(hex) {\n    return (\"00000000\" + (parseInt(hex, 16)).toString(2)).substr(-8);\n}, 'memoryOnly');\n\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":720,"y":340,"wires":[[]]},{"id":"df964a73.694328","type":"inject","z":"f9586397.5973","name":"Trigger on start","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"true","payloadType":"bool","x":120,"y":300,"wires":[["2012dbe6.92df34","7d7eee51.7878a8","4469c59cdb2428b0","05bb98ad5bbf37ab"]]},{"id":"4469c59cdb2428b0","type":"function","z":"f9586397.5973","name":"Load Module","func":"// Load Module\n// ******************************************************************\n// -*- INPUTS -*-\n// env.MODULE_ID            : module name / ID\n// env.UTILS_GC             : utils global context ID\n//\n// -*- OUTPUTS -*-\n// msg.payload              : status\n// ******************************************************************\n\n/*** START ***/\nconst system = context.global[env.get(\"MODULE_ID\")];\nconst utils = system.util.common;\n\nconst MODULE_ID = env.get(\"MODULE_ID\");\nconst UTILS = getPathObject(env.get(\"UTILS_GC\") || \"utils\");\n\n// load functionGlobalContext module into global context window\nglobal.set(MODULE_ID, context.global[MODULE_ID]);\n\n// Create a new object and assign message to payload\nfunction status(message, properties = { fill: \"green\", shape: \"dot\" }) {\n    return {\n        \"payload\": {\n            ...properties,\n            text: message\n        }\n    };\n}\n\n// Check if a value exists\nfunction exists(value) {\n\n    var valueType = typeof value;\n\n    // Check for empty string\n    if (valueType === \"string\") {\n        if (value == \"\" || (value.length == 0)) return false;\n    }\n\n    // null check\n    if (value === null) return false;\n\n    // undefined check\n    if (valueType === \"undefined\") return false;\n\n    // Empty object check\n    if (valueType == \"object\") {\n        if (Object.keys(value).length === 0) return false;\n    }\n\n    //return value != (\"\" || undefined || null || (value.length == 0));\n    return true;\n\n}\n\nclass Remote {\n    constructor(remoteId, buttons = {}) {\n        this.remoteId = remoteId;\n        this.buttons = {};\n\n        // Check if buttons is an instance of Remote, if not, convert each entry to a Button instance\n        if (!(buttons instanceof Remote)) {\n            for (const buttonId in buttons) {\n                if (buttons.hasOwnProperty(buttonId)) {\n                    this.addButton(buttonId, buttons[buttonId]);\n                }\n            }\n        }\n    }\n\n    addButton(buttonId, sourceButton = null) {\n        const button = sourceButton instanceof Button ? sourceButton : new Button(buttonId, sourceButton);\n        this.buttons[buttonId] = button;\n        return button;\n    }\n\n    getId() {\n        return this.remoteId;\n    }\n\n    getObject() {\n        const remoteObject = {};\n        Object.keys(this.buttons).forEach(buttonId => {\n            remoteObject[buttonId] = this.buttons[buttonId].getObject();\n        });\n        return remoteObject;\n    }\n}\n\nclass Button {\n    constructor(buttonId, commands = {}) {\n        this.buttonId = buttonId;\n        this.commands = {};\n\n        // Check if commands is an instance of Button, if not, convert each entry to a Command instance\n        if (!(commands instanceof Button)) {\n            for (const commandId in commands) {\n                if (commands.hasOwnProperty(commandId)) {\n                    this.addCommand(commandId, commands[commandId]);\n                }\n            }\n        }\n    }\n\n    addCommand(commandId, sourceCommand = null) {\n        const command = sourceCommand instanceof Command ? sourceCommand : new Command(commandId, sourceCommand);\n        this.commands[commandId] = command;\n        return command;\n    }\n\n    getId() {\n        return this.buttonId;\n    }\n\n    getObject() {\n        const buttonObject = {};\n        Object.keys(this.commands).forEach(commandId => {\n            buttonObject[commandId] = this.commands[commandId].getObject();\n        });\n        return buttonObject;\n    }\n}\n\nclass Command {\n    constructor(commandId, action = {}) {\n        this.commandId = commandId;\n        this.action = action;\n    }\n\n    getId() {\n        return this.commandId;\n    }\n\n    getObject() {\n        return this.action;\n    }\n}\n\n\nclass RemoteInterface {\n    constructor(remoteConfig = {}) {\n        this.remotes = {};\n        if (remoteConfig instanceof Remote) {\n            this.setRemote(remoteConfig.getId(), remoteConfig);\n        } else {\n            const remotes = remoteConfig.remotes || {};\n            Object.keys(remotes).forEach(remoteId => {\n                this.setRemote(remoteId, remotes[remoteId]);\n            });\n        }\n    }\n\n\n    setRemote(remoteId, sourceRemote = null) {\n        if (sourceRemote instanceof Remote) {\n            this.remotes[remoteId] = sourceRemote;\n        } else if (sourceRemote) {\n\n            if (!validateRemote(sourceRemote)) {\n                throw new Error('Invalid remote configuration');\n            }\n            this.remotes[remoteId] = new Remote(remoteId, sourceRemote);\n        } else {\n            this.remotes[remoteId] = new Remote(remoteId);\n        }\n        return this.remotes[remoteId];\n    }\n\n    setButton(remoteId, buttonId, sourceButton = null) {\n        if (!this.remotes[remoteId]) {\n            this.setRemote(remoteId); // Ensure remote exists before setting button\n        }\n        const button = this.remotes[remoteId].addButton(buttonId, sourceButton);\n        return button;\n    }\n\n\n    setCommand(remoteId, buttonId, commandId, sourceCommand = null) {\n        if (!this.remotes[remoteId]) {\n            this.setRemote(remoteId);\n        }\n        if (!this.remotes[remoteId].buttons[buttonId]) {\n            this.setButton(remoteId, buttonId);\n        }\n        const button = this.remotes[remoteId].buttons[buttonId];\n        const command = button.addCommand(commandId, sourceCommand);\n        return command;\n    }\n\n    getCommand(remoteId, buttonId, commandId) {\n        const remote = this.remotes[remoteId];\n\n        if (!remote) {\n            throw new Error(`Remote not found for ID ${remoteId}`);\n        }\n\n        const button = remote.buttons[buttonId];\n        if (!button) {\n            throw new Error(`Button not found for ID ${buttonId}`);\n        }\n\n        const command = button.commands[commandId];\n        if (!command) {\n            throw new Error(`Command not found for ID ${commandId}`);\n        }\n\n        return command;\n    }\n\n    getRemoteIds() {\n        return Object.keys(this.remotes);\n    }\n\n    // Ignore this, it's for debugging\n    getButtonIds2(remoteId) {\n        if (this.remotes[remoteId]) {\n            return Object.keys(this.remotes[remoteId].buttons);\n        }\n        return [];\n    }\n\n    getButtonIds(remoteId) {\n        if (this.remotes[remoteId]) {\n            if (this.remotes[remoteId] instanceof Button) {\n                // If the value is an instance of Button, return its ID\n                return [this.remotes[remoteId].getId()];\n            } else {\n                // Otherwise, assume it's an object with button IDs as keys\n                return Object.keys(this.remotes[remoteId]);\n            }\n        }\n        return [];\n    }\n\n    getCommandIds(remoteId, buttonId) {\n        if (this.remotes[remoteId] && this.remotes[remoteId].buttons[buttonId]) {\n            return Object.keys(this.remotes[remoteId].buttons[buttonId].commands);\n        }\n        return [];\n    }\n\n    getObject() {\n        return {\n            remotes: this.remotes\n        };\n    }\n}\n\n// Validation functions\nfunction validateRemote(remoteConfig) {\n    if (remoteConfig instanceof Remote) {\n        // If remoteConfig is already an instance of Remote, it's valid\n        return true;\n    } else if (typeof remoteConfig === 'object' && remoteConfig !== null) {\n        const remoteInstance = new Remote('remoteId');\n\n        // Iterate over each button in the remote\n        Object.keys(remoteConfig).forEach(buttonId => {\n            const commandConfigs = remoteConfig[buttonId];\n            const buttonInstance = new Button(buttonId);\n\n            // Iterate over each command in the button\n            Object.keys(commandConfigs).forEach(commandId => {\n                const commandInstance = new Command(commandId, commandConfigs[commandId]);\n\n                // Add the command to the button\n                buttonInstance.addCommand(commandId, commandInstance);\n            });\n\n            // Add the button to the remote\n            remoteInstance.addButton(buttonId, buttonInstance);\n        });\n\n        // Validate the remote instance\n        const isValid = validateRemote(remoteInstance);\n        return isValid;\n    } else {\n        return false; // Invalid remote configuration\n    }\n}\n\n\n\nfunction validateButton(buttonConfig) {\n    if (buttonConfig instanceof Button) {\n        // If buttonConfig is an instance of Button class, we'll validate its commands\n        for (const commandId in buttonConfig.commands) {\n            if (!buttonConfig.commands.hasOwnProperty(commandId)) {\n                continue;\n            }\n            const command = buttonConfig.commands[commandId];\n            if (!(command instanceof Command)) {\n                return false; // Invalid command within the button\n            }\n            // Optionally, add specific validation logic for command configuration here\n        }\n        return true; // All checks passed\n    } else if (typeof buttonConfig === 'object' && buttonConfig !== null && buttonConfig.hasOwnProperty('commands')) {\n        // If buttonConfig is an object representation, we'll recursively call validateCommand for each command\n        for (const commandId in buttonConfig.commands) {\n            if (!buttonConfig.commands.hasOwnProperty(commandId)) {\n                continue;\n            }\n            if (!validateCommand(buttonConfig.commands[commandId])) {\n                return false; // Invalid command configuration\n            }\n        }\n        return true; // All checks passed\n    } else {\n        return false; // Invalid button configuration\n    }\n}\n\nfunction validateCommand(commandConfig) {\n    if (commandConfig instanceof Command) {\n        // If commandConfig is an instance of Command class, it's valid\n        return true;\n    } else if (typeof commandConfig === 'object' && commandConfig !== null) {\n        // If commandConfig is an object representation, we'll check its properties\n        if (commandConfig.hasOwnProperty('commandId') && commandConfig.hasOwnProperty('action')) {\n            // Optionally, add specific validation logic for command configuration here\n            return true; // All checks passed\n        }\n    }\n    return false; // Invalid command configuration\n}\n\nclass DeviceManager {\n    constructor(mapping = {}) {\n        this.devices = mapping;\n    }\n\n    setDevice(device_id, data) {\n        this.devices[device_id] = data;\n    }\n\n    getDevice(device_id) {\n        return this.devices[device_id];\n    }\n\n    removeDevice(device_id) {\n        if (this.devices.hasOwnProperty(device_id)) {\n            delete this.devices[device_id];\n        }\n    }\n\n    getDevices() {\n        return this.devices;\n    }\n}\n\nclass DebounceTimerManager {\n    constructor() {\n        this.timers = {};\n    }\n\n    createTimer(attributeValues, debounceTimers, callback, delay) {\n        let nestedObject = debounceTimers;\n        for (const attrValue of attributeValues) {\n            nestedObject[attrValue] = nestedObject[attrValue] || {};\n            nestedObject = nestedObject[attrValue];\n        }\n        if (!nestedObject.hasOwnProperty('timer')) {\n            nestedObject.timer = setTimeout(callback, delay);\n        }\n    }\n\n    updateTimer(attributeValues, debounceTimers, callback, delay) {\n        this.clearTimer(attributeValues, debounceTimers);\n        this.createTimer(attributeValues, debounceTimers, callback, delay);\n    }\n\n    clearTimer(attributeValues, debounceTimers) {\n        let nestedObject = debounceTimers;\n        for (const attrValue of attributeValues) {\n            if (!nestedObject[attrValue]) {\n                return;\n            }\n            nestedObject = nestedObject[attrValue];\n        }\n        if (nestedObject.timer) {\n            clearTimeout(nestedObject.timer);\n            delete nestedObject.timer;\n        }\n    }\n}\n\n// Append character to end of string if not present\nfunction append(value, character) {\n\n    // Check if end of string matches character\n    if (value.charAt(value.length - character.length) !== character) {\n\n        // Append character if not found\n        value = value + character;\n    }\n\n    return value;\n\n}\n\n// Remove character from end of string\nfunction abate(value, character) {\n\n    // Check if end of string matches character(s) \n    if (value.charAt(value.length - character.length) === character) {\n\n        // Abate character if found\n        value = value.substring(0, value.length - character.length);\n    }\n\n    return value;\n\n}\n\nfunction getPathObject(path) {\n\n    return {\n        REPOSITORY: append(path, \".\"),\n        OBJECT: abate(path, \".\")\n    };\n}\n\n// Cast Object to array\nfunction castToArray(value) {\n    return (Array.isArray(value)) ? value : [value];\n}\n\n// Function to get attribute values from event data\nfunction getEventAttributes(event, attributes) {\n    return attributes.map(attr => event[attr]);\n}\n\nvar loaded = false;\nvar gc = global.keys();\n\n// Check if module object is loaded\nfor (let i = 0; i < gc.length; i++) {\n\n    if (gc[i] === MODULE_ID) loaded = true;\n\n}\n\n// General\nglobal.set(`${UTILS.REPOSITORY}exists`, exists);\nglobal.set(`${UTILS.REPOSITORY}getEventAttributes`, getEventAttributes);\n\n// RemoteInterface\nglobal.set(`${UTILS.REPOSITORY}RemoteInterface`, RemoteInterface);\nglobal.set(`${UTILS.REPOSITORY}Remote`, Remote);\nglobal.set(`${UTILS.REPOSITORY}Button`, Button);\nglobal.set(`${UTILS.REPOSITORY}Command`, Command);\n\n// Device Manager\nglobal.set(`${UTILS.REPOSITORY}DeviceManager`, DeviceManager);\n\n// Timer Managers\nglobal.set(`${UTILS.REPOSITORY}DebounceTimerManager`, DebounceTimerManager);\n\nglobal.set(`${UTILS.REPOSITORY}status`, status);\nglobal.set(`${UTILS.REPOSITORY}castToArray`, castToArray);\n\n// Return loaded status\nif (loaded) return status(`Module Loaded [${MODULE_ID}]`);\n\n// Return non-loaded status\nreturn status(`Module Not loaded [${MODULE_ID}]`);\n\n/*** END ***/","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":530,"y":300,"wires":[[]]},{"id":"8d636e35e38fbe0d","type":"function","z":"f9586397.5973","name":"domain","func":"// Domain Logic\n// General Use-Case Domain Logic\n// ******************************************************************\n// -*- INPUTS -*-\n//\n// -*- OUTPUTS -*-\n// msg.payload.domain       : global variable value\n// msg.global_id            : Actual Global Context identifier\n// ******************************************************************\n\n/*** START ***/\n\nclass Entity {\n    constructor(entityObject) {\n        this._aliases = entityObject.aliases || [];\n        this._areaId = entityObject.area_id || null;\n        this._capabilities = entityObject.capabilities || null;\n        this._configEntryId = entityObject.config_entry_id || null;\n        this._deviceClass = entityObject.device_class || null;\n        this._deviceId = entityObject.device_id || null;\n        this._disabledBy = entityObject.disabled_by || null;\n        this._entityCategory = entityObject.entity_category || null;\n        this._entityId = entityObject.entity_id || null;\n        this._hiddenBy = entityObject.hidden_by || null;\n        this._icon = entityObject.icon || null;\n        this._id = entityObject.id || null;\n        this._hasEntityName = entityObject.has_entity_name || null;\n        this._name = entityObject.name || null;\n        this._options = entityObject.options || null;\n        this._originalDeviceClass = entityObject.original_device_class || null;\n        this._originalIcon = entityObject.original_icon || null;\n        this._originalName = entityObject.original_name || null;\n        this._platform = entityObject.platform || null;\n        this._supportedFeatures = entityObject.supported_features || null;\n        this._translationKey = entityObject.translation_key || null;\n        this._uniqueId = entityObject.unique_id || null;\n        this._unitOfMeasurement = entityObject.unit_of_measurement || null;\n    }\n\n    get aliases() {\n        return this._aliases;\n    }\n\n    get areaId() {\n        return this._areaId;\n    }\n\n    get capabilities() {\n        return this._capabilities;\n    }\n\n    get configEntryId() {\n        return this._configEntryId;\n    }\n\n    get deviceClass() {\n        return this._deviceClass;\n    }\n\n    get deviceId() {\n        return this._deviceId;\n    }\n\n    get disabledBy() {\n        return this._disabledBy;\n    }\n\n    get entityCategory() {\n        return this._entityCategory;\n    }\n\n    get entityId() {\n        return this._entityId;\n    }\n\n    get hiddenBy() {\n        return this._hiddenBy;\n    }\n\n    get icon() {\n        return this._icon;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get hasEntityName() {\n        return this._hasEntityName;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get options() {\n        return this._options;\n    }\n\n    get originalDeviceClass() {\n        return this._originalDeviceClass;\n    }\n\n    get originalIcon() {\n        return this._originalIcon;\n    }\n\n    get originalName() {\n        return this._originalName;\n    }\n\n    get platform() {\n        return this._platform;\n    }\n\n    get supportedFeatures() {\n        return this._supportedFeatures;\n    }\n\n    get translationKey() {\n        return this._translationKey;\n    }\n\n    get uniqueId() {\n        return this._uniqueId;\n    }\n\n    get unitOfMeasurement() {\n        return this._unitOfMeasurement;\n    }\n}\n\nclass Area {\n    constructor(areaObject) {\n        this._aliases = areaObject.aliases || [];\n        this._name = areaObject.name || null;\n        this._id = areaObject.id || null;\n        this._picture = areaObject.picture || null;\n    }\n\n    get aliases() {\n        return this._aliases;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get picture() {\n        return this._picture;\n    }\n}\n\nclass Device {\n    constructor(deviceObject) {\n        this._area_id = deviceObject.area_id || null;\n        this._config_entries = deviceObject.config_entries || [];\n        this._configuration_url = deviceObject.configuration_url || null;\n        this._connections = deviceObject.connections || [];\n        this._disabled_by = deviceObject.disabled_by || null;\n        this._entry_type = deviceObject.entry_type || null;\n        this._hw_version = deviceObject.hw_version || null;\n        this._id = deviceObject.id || null;\n        this._identifiers = deviceObject.identifiers || [];\n        this._manufacturer = deviceObject.manufacturer || null;\n        this._model = deviceObject.model || null;\n        this._name_by_user = deviceObject.name_by_user || null;\n        this._name = deviceObject.name || null;\n        this._sw_version = deviceObject.sw_version || null;\n        this._via_device_id = deviceObject.via_device_id || null;\n    }\n\n    get area_id() {\n        return this._area_id;\n    }\n\n    get config_entries() {\n        return this._config_entries;\n    }\n\n    get configuration_url() {\n        return this._configuration_url;\n    }\n\n    get connections() {\n        return this._connections;\n    }\n\n    get disabled_by() {\n        return this._disabled_by;\n    }\n\n    get entry_type() {\n        return this._entry_type;\n    }\n\n    get hw_version() {\n        return this._hw_version;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get identifiers() {\n        return this._identifiers;\n    }\n\n    get manufacturer() {\n        return this._manufacturer;\n    }\n\n    get model() {\n        return this._model;\n    }\n\n    get name_by_user() {\n        return this._name_by_user;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get sw_version() {\n        return this._sw_version;\n    }\n\n    get via_device_id() {\n        return this._via_device_id;\n    }\n}\n\n\nconst domain = {\n\n    models: {\n        Entity,\n        Area,\n        Device\n    }\n}\n\nreturn msg;\n/*** END ***/\n\n/*** HELPERS ***/\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":220,"y":360,"wires":[[]]},{"id":"b85b43214d3bf1da","type":"function","z":"f9586397.5973","name":"ports","func":"// Domain Logic\n// General Use-Case Domain Logic\n// ******************************************************************\n// -*- INPUTS -*-\n//\n// -*- OUTPUTS -*-\n// msg.payload.domain       : global variable value\n// msg.global_id            : Actual Global Context identifier\n// ******************************************************************\n\n/*** START ***/\n\nclass Entity {\n    constructor(entityObject) {\n        this._aliases = entityObject.aliases || [];\n        this._areaId = entityObject.area_id || null;\n        this._capabilities = entityObject.capabilities || null;\n        this._configEntryId = entityObject.config_entry_id || null;\n        this._deviceClass = entityObject.device_class || null;\n        this._deviceId = entityObject.device_id || null;\n        this._disabledBy = entityObject.disabled_by || null;\n        this._entityCategory = entityObject.entity_category || null;\n        this._entityId = entityObject.entity_id || null;\n        this._hiddenBy = entityObject.hidden_by || null;\n        this._icon = entityObject.icon || null;\n        this._id = entityObject.id || null;\n        this._hasEntityName = entityObject.has_entity_name || null;\n        this._name = entityObject.name || null;\n        this._options = entityObject.options || null;\n        this._originalDeviceClass = entityObject.original_device_class || null;\n        this._originalIcon = entityObject.original_icon || null;\n        this._originalName = entityObject.original_name || null;\n        this._platform = entityObject.platform || null;\n        this._supportedFeatures = entityObject.supported_features || null;\n        this._translationKey = entityObject.translation_key || null;\n        this._uniqueId = entityObject.unique_id || null;\n        this._unitOfMeasurement = entityObject.unit_of_measurement || null;\n    }\n\n    get aliases() {\n        return this._aliases;\n    }\n\n    get areaId() {\n        return this._areaId;\n    }\n\n    get capabilities() {\n        return this._capabilities;\n    }\n\n    get configEntryId() {\n        return this._configEntryId;\n    }\n\n    get deviceClass() {\n        return this._deviceClass;\n    }\n\n    get deviceId() {\n        return this._deviceId;\n    }\n\n    get disabledBy() {\n        return this._disabledBy;\n    }\n\n    get entityCategory() {\n        return this._entityCategory;\n    }\n\n    get entityId() {\n        return this._entityId;\n    }\n\n    get hiddenBy() {\n        return this._hiddenBy;\n    }\n\n    get icon() {\n        return this._icon;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get hasEntityName() {\n        return this._hasEntityName;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get options() {\n        return this._options;\n    }\n\n    get originalDeviceClass() {\n        return this._originalDeviceClass;\n    }\n\n    get originalIcon() {\n        return this._originalIcon;\n    }\n\n    get originalName() {\n        return this._originalName;\n    }\n\n    get platform() {\n        return this._platform;\n    }\n\n    get supportedFeatures() {\n        return this._supportedFeatures;\n    }\n\n    get translationKey() {\n        return this._translationKey;\n    }\n\n    get uniqueId() {\n        return this._uniqueId;\n    }\n\n    get unitOfMeasurement() {\n        return this._unitOfMeasurement;\n    }\n}\n\nclass Area {\n    constructor(areaObject) {\n        this._aliases = areaObject.aliases || [];\n        this._name = areaObject.name || null;\n        this._id = areaObject.id || null;\n        this._picture = areaObject.picture || null;\n    }\n\n    get aliases() {\n        return this._aliases;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get picture() {\n        return this._picture;\n    }\n}\n\nclass Device {\n    constructor(deviceObject) {\n        this._area_id = deviceObject.area_id || null;\n        this._config_entries = deviceObject.config_entries || [];\n        this._configuration_url = deviceObject.configuration_url || null;\n        this._connections = deviceObject.connections || [];\n        this._disabled_by = deviceObject.disabled_by || null;\n        this._entry_type = deviceObject.entry_type || null;\n        this._hw_version = deviceObject.hw_version || null;\n        this._id = deviceObject.id || null;\n        this._identifiers = deviceObject.identifiers || [];\n        this._manufacturer = deviceObject.manufacturer || null;\n        this._model = deviceObject.model || null;\n        this._name_by_user = deviceObject.name_by_user || null;\n        this._name = deviceObject.name || null;\n        this._sw_version = deviceObject.sw_version || null;\n        this._via_device_id = deviceObject.via_device_id || null;\n    }\n\n    get area_id() {\n        return this._area_id;\n    }\n\n    get config_entries() {\n        return this._config_entries;\n    }\n\n    get configuration_url() {\n        return this._configuration_url;\n    }\n\n    get connections() {\n        return this._connections;\n    }\n\n    get disabled_by() {\n        return this._disabled_by;\n    }\n\n    get entry_type() {\n        return this._entry_type;\n    }\n\n    get hw_version() {\n        return this._hw_version;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get identifiers() {\n        return this._identifiers;\n    }\n\n    get manufacturer() {\n        return this._manufacturer;\n    }\n\n    get model() {\n        return this._model;\n    }\n\n    get name_by_user() {\n        return this._name_by_user;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get sw_version() {\n        return this._sw_version;\n    }\n\n    get via_device_id() {\n        return this._via_device_id;\n    }\n}\n\n\nconst models = {\n    Entity,\n    Area,\n    Device\n}\n\nmsg.payload.domain.models = models;\n\nreturn msg;\n/*** END ***/\n\n/*** HELPERS ***/\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":230,"y":400,"wires":[[]]},{"id":"5958ba5595c9bb1a","type":"function","z":"f9586397.5973","name":"adapters","func":"// Domain Logic\n// General Use-Case Domain Logic\n// ******************************************************************\n// -*- INPUTS -*-\n//\n// -*- OUTPUTS -*-\n// msg.payload.domain       : global variable value\n// msg.global_id            : Actual Global Context identifier\n// ******************************************************************\n\n/*** START ***/\n\nclass Entity {\n    constructor(entityObject) {\n        this._aliases = entityObject.aliases || [];\n        this._areaId = entityObject.area_id || null;\n        this._capabilities = entityObject.capabilities || null;\n        this._configEntryId = entityObject.config_entry_id || null;\n        this._deviceClass = entityObject.device_class || null;\n        this._deviceId = entityObject.device_id || null;\n        this._disabledBy = entityObject.disabled_by || null;\n        this._entityCategory = entityObject.entity_category || null;\n        this._entityId = entityObject.entity_id || null;\n        this._hiddenBy = entityObject.hidden_by || null;\n        this._icon = entityObject.icon || null;\n        this._id = entityObject.id || null;\n        this._hasEntityName = entityObject.has_entity_name || null;\n        this._name = entityObject.name || null;\n        this._options = entityObject.options || null;\n        this._originalDeviceClass = entityObject.original_device_class || null;\n        this._originalIcon = entityObject.original_icon || null;\n        this._originalName = entityObject.original_name || null;\n        this._platform = entityObject.platform || null;\n        this._supportedFeatures = entityObject.supported_features || null;\n        this._translationKey = entityObject.translation_key || null;\n        this._uniqueId = entityObject.unique_id || null;\n        this._unitOfMeasurement = entityObject.unit_of_measurement || null;\n    }\n\n    get aliases() {\n        return this._aliases;\n    }\n\n    get areaId() {\n        return this._areaId;\n    }\n\n    get capabilities() {\n        return this._capabilities;\n    }\n\n    get configEntryId() {\n        return this._configEntryId;\n    }\n\n    get deviceClass() {\n        return this._deviceClass;\n    }\n\n    get deviceId() {\n        return this._deviceId;\n    }\n\n    get disabledBy() {\n        return this._disabledBy;\n    }\n\n    get entityCategory() {\n        return this._entityCategory;\n    }\n\n    get entityId() {\n        return this._entityId;\n    }\n\n    get hiddenBy() {\n        return this._hiddenBy;\n    }\n\n    get icon() {\n        return this._icon;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get hasEntityName() {\n        return this._hasEntityName;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get options() {\n        return this._options;\n    }\n\n    get originalDeviceClass() {\n        return this._originalDeviceClass;\n    }\n\n    get originalIcon() {\n        return this._originalIcon;\n    }\n\n    get originalName() {\n        return this._originalName;\n    }\n\n    get platform() {\n        return this._platform;\n    }\n\n    get supportedFeatures() {\n        return this._supportedFeatures;\n    }\n\n    get translationKey() {\n        return this._translationKey;\n    }\n\n    get uniqueId() {\n        return this._uniqueId;\n    }\n\n    get unitOfMeasurement() {\n        return this._unitOfMeasurement;\n    }\n}\n\nclass Area {\n    constructor(areaObject) {\n        this._aliases = areaObject.aliases || [];\n        this._name = areaObject.name || null;\n        this._id = areaObject.id || null;\n        this._picture = areaObject.picture || null;\n    }\n\n    get aliases() {\n        return this._aliases;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get picture() {\n        return this._picture;\n    }\n}\n\nclass Device {\n    constructor(deviceObject) {\n        this._area_id = deviceObject.area_id || null;\n        this._config_entries = deviceObject.config_entries || [];\n        this._configuration_url = deviceObject.configuration_url || null;\n        this._connections = deviceObject.connections || [];\n        this._disabled_by = deviceObject.disabled_by || null;\n        this._entry_type = deviceObject.entry_type || null;\n        this._hw_version = deviceObject.hw_version || null;\n        this._id = deviceObject.id || null;\n        this._identifiers = deviceObject.identifiers || [];\n        this._manufacturer = deviceObject.manufacturer || null;\n        this._model = deviceObject.model || null;\n        this._name_by_user = deviceObject.name_by_user || null;\n        this._name = deviceObject.name || null;\n        this._sw_version = deviceObject.sw_version || null;\n        this._via_device_id = deviceObject.via_device_id || null;\n    }\n\n    get area_id() {\n        return this._area_id;\n    }\n\n    get config_entries() {\n        return this._config_entries;\n    }\n\n    get configuration_url() {\n        return this._configuration_url;\n    }\n\n    get connections() {\n        return this._connections;\n    }\n\n    get disabled_by() {\n        return this._disabled_by;\n    }\n\n    get entry_type() {\n        return this._entry_type;\n    }\n\n    get hw_version() {\n        return this._hw_version;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get identifiers() {\n        return this._identifiers;\n    }\n\n    get manufacturer() {\n        return this._manufacturer;\n    }\n\n    get model() {\n        return this._model;\n    }\n\n    get name_by_user() {\n        return this._name_by_user;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get sw_version() {\n        return this._sw_version;\n    }\n\n    get via_device_id() {\n        return this._via_device_id;\n    }\n}\n\n\nconst models = {\n    Entity,\n    Area,\n    Device\n}\n\nmsg.payload.domain.models = models;\n\nreturn msg;\n/*** END ***/\n\n/*** HELPERS ***/\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":220,"y":440,"wires":[[]]},{"id":"9a27cdc622ef191c","type":"function","z":"f9586397.5973","name":"Utility Functions","func":"/** Utility Functions **/\n\n// Default to utils object if no UTIL_GC environment variable passed\nconst UTILS = getPathObject(env.get(\"UTIL_GC\") || \"utils\");\nconst object_id = UTILS.REPOSITORY;\n\nconst SOURCE = getPathObject(env.get(\"GLOBAL_ID\") || \"system\");\n\nconst ENTITIES = getPathObject(`${SOURCE.REPOSITORY}entities`);\nconst AREAS = getPathObject(`${SOURCE.REPOSITORY}areas`);\nconst DEVICES = getPathObject(`${SOURCE.REPOSITORY}devices`);\nconst OCCUPANCY = getPathObject(`${SOURCE.REPOSITORY}occupancy`);\nconst PRESENCE = getPathObject(`${SOURCE.REPOSITORY}presence`);\n\n// For testing / debugging purposes\nfunction healthCheck () {\n    return true;\n}\n\n// For global context path setup\nfunction getPathObject(path) {\n\n    return {\n        REPOSITORY: append(path, \".\"),\n        OBJECT: abate(path, \".\")\n    };\n}\n\n// Rounding function with precision\nfunction round(value, precision) {\n\n    // Return raw value if no precision passed\n    if (!exists(precision)) return value;\n\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(value * multiplier) / multiplier;\n}\n\n// Check if entity_id was passed, and remove domain\nfunction getGlobalID(globalID) {\n\n    // If an entity_id was passed, remove domain\n    if (exists(globalID) && globalID.includes(\".\")) {\n\n        globalID = globalID.split(\".\")[1];\n\n    }\n\n    // Return global ID\n    return globalID;\n}\n\n// Check if a value exists\nfunction exists(value) {\n\n    var valueType = typeof value;\n\n    // Check for empty string\n    if (valueType === \"string\") {\n        if (value == \"\" || (value.length == 0)) return false;\n    }\n\n    // null check\n    if (value === null) return false;\n\n    // undefined check\n    if (valueType === \"undefined\") return false;\n\n    // Empty object check\n    if (valueType == \"object\") {\n        if (Object.keys(value).length === 0) return false;\n    }\n\n    //return value != (\"\" || undefined || null || (value.length == 0));\n    return true;\n\n}\n\n// Create a new object and assign message to payload\nfunction status(message, properties = { fill: \"green\", shape: \"dot\" }) {\n    return {\n        \"payload\": {\n            ...properties,\n            text: message\n        }\n    };\n}\n\n// Create a new object and assign message to payload (finish for me pls <3)\nfunction statusOld(message) {\n    return { \"payload\": message };\n}\n\n// Sets an object attribute to a given value\nfunction setAttribute (property, attribute, value) {\n    \n    // Check if msg property is an object\n    if (!(typeof property === 'object')) {\n        property = {};\n    }\n    \n    // If attribute not passed, default to payload\n    if (!exists(attribute)) {\n        attribute = \"payload\";\n    }\n\n    // Set value\n    property[attribute] = value;\n\n    return property;\n\n}\n\n// Append character to end of string if not present\nfunction append(value, character) {\n\n    // Check if end of string matches character\n    if (value.charAt(value.length - character.length) !== character) {\n\n        // Append character if not found\n        value = value + character;\n    }\n\n    return value;\n\n}\n\n// Remove character from end of string\nfunction abate(value, character) {\n\n    // Check if end of string matches character(s) \n    if (value.charAt(value.length - character.length) === character) {\n\n        // Abate character if found\n        value = value.substring(0, value.length - character.length);\n    }\n\n    return value;\n\n}\n\n// Cast Object to array\nfunction castToArray(value) {\n    return (Array.isArray(value)) ? value : [value];\n}\n\n// Function to get attribute values from event data\nfunction getEventAttributes(event, attributes) {\n    return attributes.map(attr => event[attr]);\n}\n\n// Function to get an entity from an entities object\nfunction getEntity(entity_id) {\n    return new Promise((resolve, reject) => {\n\n        // Timeout value in milliseconds\n        const TIMEOUT = 10000; \n\n        const entities = global.get(ENTITIES.OBJECT);\n        //const entities = EntitiesRepository.getObject();\n\n        // Check if entities are already available\n        if (exists(entities)) {\n            resolve(entities[entity_id]);\n        } else {\n            const waitManager = new WaitTimerManager();\n\n            // Function to handle timer callback\n            const timerCallback = function (error) {\n                if (error) {\n                    // Timeout occurred\n                    reject(new Error(`Entities not loaded within ${TIMEOUT} ms`));\n                } else {\n                    // Re-fetch the entities object and resolve the promise\n                    const loaded_entities = global.get(ENTITIES.OBJECT);\n                    //const loaded_entities = EntitiesRepository.getObject();\n                    if (loaded_entities) {\n                        // Fetch the entity from the entities object\n                        resolve(loaded_entities[entity_id]);\n                        // Cancel the wait timer\n                        waitManager.clearWaitTimer(ENTITIES.OBJECT); \n                    }\n                    // Entities object not available yet, retrying...\n                }\n            };\n\n            // Create wait timer\n            waitManager.createWaitTimer(ENTITIES.OBJECT, timerCallback, TIMEOUT);\n            node.warn(\"Waiting for entities...\");\n        }\n    });\n}\n\n// Function to get an object from global context\nfunction waitForGlobalContext(global_id, TIMEOUT = 10000) {\n    return new Promise((resolve, reject) => {\n\n        const object_value = global.get(global_id);\n\n        // Check if value is already available\n        if (exists(object_value)) {\n            resolve(object_value);\n        } else {\n            const waitManager = new WaitTimerManager();\n\n            // Function to handle timer callback\n            const timerCallback = function (error) {\n                if (error) {\n                    // Timeout occurred\n                    reject(new Error(`Object not loaded within ${TIMEOUT} ms`));\n                } else {\n                    // Re-fetch the object and resolve the promise\n                    const loaded_object_value = global.get(global_id);\n                    node.warn(`Reloading object: ${loaded_object_value}`);\n                    if (loaded_object_value) {\n                        node.warn(`Object loaded (${global_id}): ${loaded_object_value}`);\n                        resolve(loaded_object_value);\n                        // Cancel the wait timer\n                        waitManager.clearWaitTimer(global_id);\n                    }\n                    node.warn(`Object not available yet, retrying...`);\n                }\n            };\n\n            // Create wait timer\n            waitManager.createWaitTimer(global_id, timerCallback, TIMEOUT);\n            node.warn(\"Waiting for object...\");\n        }\n    });\n}\n\nfunction getGlobalAsync(globalId, timeout = 10000) {\n    return new Promise((resolve, reject) => {\n        const interval = setInterval(() => {\n            const obj = global.get(globalId);\n            if (obj !== undefined) {\n                clearInterval(interval);\n                resolve(obj);\n            }\n        }, 1000); // Check every second\n\n        setTimeout(() => {\n            clearInterval(interval);\n            reject(new Error(`Timeout reached while waiting for global context object: ${globalId}`));\n        }, timeout);\n    });\n}\n\n\n//**API **//\n\nfunction createResponseObject(response_code, message) {\n    return {\n        \"response_code\": response_code,\n        \"data\": message\n    }\n}\n\nfunction generateToggleSwitchValueTemplate(toggleEntityId, triggerEntityId, triggerEntityState) {\n    return `{% if is_state('${toggleEntityId}', 'on') %}\n        {{ is_state('${triggerEntityId}', '${triggerEntityState}') }}\n        {% else %}\n        {{ is_state('${toggleEntityId}', 'on') }}\n        {% endif %}`;\n}\n\nfunction generateTemplateSwitchObject(switchId, friendlyName, valueTemplate, turnOnAction, turnOffAction, iconTemplate) {\n    const switchObject = {\n        [switchId]: {\n            friendly_name: friendlyName,\n            value_template: valueTemplate,\n            turn_on: [turnOnAction],\n            turn_off: [turnOffAction],\n            icon_template: iconTemplate\n        }\n    };\n    return switchObject;\n}\n\nfunction generateYamlTemplateObject(entity_type) {\n    const yamlObject = {\n        platform: 'template',\n        [entity_type]: {}\n    };\n    return [yamlObject];\n}\n\nfunction addEntityToTemplateObject(yamlObject, entity_type, entity) {\n    yamlObject[0][entity_type] = {\n        ...yamlObject[0][entity_type],\n        ...entity\n    };\n    return yamlObject;\n}\n\nfunction createTurnOnOffObject(service, data = {}) {\n    return {\n        turn_on: [\n            {\n                service: service,\n                ...data.turn_on // Spread additional turn_on data if provided\n            }\n        ],\n        turn_off: [\n            {\n                service: service,\n                ...data.turn_off // Spread additional turn_off data if provided\n            }\n        ]\n    };\n}\n\nfunction createIconTemplate(onStateIcon, offStateIcon = null, triggerEntityId = null, triggerEntityState = null) {\n    if (!offStateIcon) {\n        return `mdi:${onStateIcon}`;\n    } else {\n        return `{% if is_state('${triggerEntityId}', '${triggerEntityState}') %}\n            mdi:${onStateIcon}\n        {% else %}\n            mdi:${offStateIcon}\n        {% endif %}`;\n    }\n}\n\nfunction getFileNameFromPath(filePath) {\n    const parts = filePath.split('/');\n    return parts[parts.length - 1];\n}\n\nfunction mapArrayToDict(entities, key) {\n    const entityDict = {};\n\n    entities.forEach(entity => {\n        entityDict[entity[key]] = entity;\n    });\n\n    return entityDict;\n}\n\nfunction currentState(entityId) {\n    return global.get(\"homeassistant.homeAssistant.states\")[entityId];\n}\n\nclass Remote {\n    constructor(remoteId, buttons = {}) {\n        this.remoteId = remoteId;\n        this.buttons = {};\n\n        // Check if buttons is an instance of Remote, if not, convert each entry to a Button instance\n        if (!(buttons instanceof Remote)) {\n            for (const buttonId in buttons) {\n                if (buttons.hasOwnProperty(buttonId)) {\n                    this.addButton(buttonId, buttons[buttonId]);\n                }\n            }\n        }\n    }\n\n    addButton(buttonId, sourceButton = null) {\n        const button = sourceButton instanceof Button ? sourceButton : new Button(buttonId, sourceButton);\n        this.buttons[buttonId] = button;\n        return button;\n    }\n\n    getId() {\n        return this.remoteId;\n    }\n\n    getObject() {\n        const remoteObject = {};\n        Object.keys(this.buttons).forEach(buttonId => {\n            remoteObject[buttonId] = this.buttons[buttonId].getObject();\n        });\n        return remoteObject;\n    }\n}\n\nclass Button {\n    constructor(buttonId, commands = {}) {\n        this.buttonId = buttonId;\n        this.commands = {};\n\n        // Check if commands is an instance of Button, if not, convert each entry to a Command instance\n        if (!(commands instanceof Button)) {\n            for (const commandId in commands) {\n                if (commands.hasOwnProperty(commandId)) {\n                    this.addCommand(commandId, commands[commandId]);\n                }\n            }\n        }\n    }\n\n    addCommand(commandId, sourceCommand = null) {\n        const command = sourceCommand instanceof Command ? sourceCommand : new Command(commandId, sourceCommand);\n        this.commands[commandId] = command;\n        return command;\n    }\n\n    getId() {\n        return this.buttonId;\n    }\n\n    getObject() {\n        const buttonObject = {};\n        Object.keys(this.commands).forEach(commandId => {\n            buttonObject[commandId] = this.commands[commandId].getObject();\n        });\n        return buttonObject;\n    }\n}\n\nclass Command {\n    constructor(commandId, action = {}) {\n        this.commandId = commandId;\n        this.action = action;\n    }\n\n    getId() {\n        return this.commandId;\n    }\n\n    getObject() {\n        return this.action;\n    }\n}\n\n\nclass RemoteInterface {\n    constructor(remoteConfig = {}) {\n        this.remotes = {};\n        if (remoteConfig instanceof Remote) {\n            this.setRemote(remoteConfig.getId(), remoteConfig);\n        } else {\n            const remotes = remoteConfig.remotes || {};\n            Object.keys(remotes).forEach(remoteId => {\n                this.setRemote(remoteId, remotes[remoteId]);\n            });\n        }\n    }\n\n\n    setRemote(remoteId, sourceRemote = null) {\n        if (sourceRemote instanceof Remote) {\n            this.remotes[remoteId] = sourceRemote;\n        } else if (sourceRemote) {\n\n            if (!validateRemote(sourceRemote)) {\n                throw new Error('Invalid remote configuration');\n            }\n            this.remotes[remoteId] = new Remote(remoteId, sourceRemote);\n        } else {\n            this.remotes[remoteId] = new Remote(remoteId);\n        }\n        return this.remotes[remoteId];\n    }\n\n    setButton(remoteId, buttonId, sourceButton = null) {\n        if (!this.remotes[remoteId]) {\n            this.setRemote(remoteId); // Ensure remote exists before setting button\n        }\n        const button = this.remotes[remoteId].addButton(buttonId, sourceButton);\n        return button;\n    }\n\n\n    setCommand(remoteId, buttonId, commandId, sourceCommand = null) {\n        if (!this.remotes[remoteId]) {\n            this.setRemote(remoteId);\n        }\n        if (!this.remotes[remoteId].buttons[buttonId]) {\n            this.setButton(remoteId, buttonId);\n        }\n        const button = this.remotes[remoteId].buttons[buttonId];\n        const command = button.addCommand(commandId, sourceCommand);\n        return command;\n    }\n\n    getCommand(remoteId, buttonId, commandId) {\n        const remote = this.remotes[remoteId];\n\n        if (!remote) {\n            throw new Error(`Remote not found for ID ${remoteId}`);\n        }\n\n        const button = remote.buttons[buttonId];\n        if (!button) {\n            throw new Error(`Button not found for ID ${buttonId}`);\n        }\n\n        const command = button.commands[commandId];\n        if (!command) {\n            throw new Error(`Command not found for ID ${commandId}`);\n        }\n\n        return command;\n    }\n\n    getRemoteIds() {\n        return Object.keys(this.remotes);\n    }\n\n    // Ignore this, it's for debugging\n    getButtonIds2(remoteId) {\n        if (this.remotes[remoteId]) {\n            return Object.keys(this.remotes[remoteId].buttons);\n        }\n        return [];\n    }\n\n    getButtonIds(remoteId) {\n        if (this.remotes[remoteId]) {\n            if (this.remotes[remoteId] instanceof Button) {\n                // If the value is an instance of Button, return its ID\n                return [this.remotes[remoteId].getId()];\n            } else {\n                // Otherwise, assume it's an object with button IDs as keys\n                return Object.keys(this.remotes[remoteId]);\n            }\n        }\n        return [];\n    }\n\n    getCommandIds(remoteId, buttonId) {\n        if (this.remotes[remoteId] && this.remotes[remoteId].buttons[buttonId]) {\n            return Object.keys(this.remotes[remoteId].buttons[buttonId].commands);\n        }\n        return [];\n    }\n\n    getObject() {\n        return {\n            remotes: this.remotes\n        };\n    }\n}\n\n// Validation functions\nfunction validateRemote(remoteConfig) {\n    if (remoteConfig instanceof Remote) {\n        // If remoteConfig is already an instance of Remote, it's valid\n        return true;\n    } else if (typeof remoteConfig === 'object' && remoteConfig !== null) {\n        const remoteInstance = new Remote('remoteId');\n\n        // Iterate over each button in the remote\n        Object.keys(remoteConfig).forEach(buttonId => {\n            const commandConfigs = remoteConfig[buttonId];\n            const buttonInstance = new Button(buttonId);\n\n            // Iterate over each command in the button\n            Object.keys(commandConfigs).forEach(commandId => {\n                const commandInstance = new Command(commandId, commandConfigs[commandId]);\n\n                // Add the command to the button\n                buttonInstance.addCommand(commandId, commandInstance);\n            });\n\n            // Add the button to the remote\n            remoteInstance.addButton(buttonId, buttonInstance);\n        });\n\n        // Validate the remote instance\n        const isValid = validateRemote(remoteInstance);\n        return isValid;\n    } else {\n        return false; // Invalid remote configuration\n    }\n}\n\n\n\nfunction validateButton(buttonConfig) {\n    if (buttonConfig instanceof Button) {\n        // If buttonConfig is an instance of Button class, we'll validate its commands\n        for (const commandId in buttonConfig.commands) {\n            if (!buttonConfig.commands.hasOwnProperty(commandId)) {\n                continue;\n            }\n            const command = buttonConfig.commands[commandId];\n            if (!(command instanceof Command)) {\n                return false; // Invalid command within the button\n            }\n            // Optionally, add specific validation logic for command configuration here\n        }\n        return true; // All checks passed\n    } else if (typeof buttonConfig === 'object' && buttonConfig !== null && buttonConfig.hasOwnProperty('commands')) {\n        // If buttonConfig is an object representation, we'll recursively call validateCommand for each command\n        for (const commandId in buttonConfig.commands) {\n            if (!buttonConfig.commands.hasOwnProperty(commandId)) {\n                continue;\n            }\n            if (!validateCommand(buttonConfig.commands[commandId])) {\n                return false; // Invalid command configuration\n            }\n        }\n        return true; // All checks passed\n    } else {\n        return false; // Invalid button configuration\n    }\n}\n\nfunction validateCommand(commandConfig) {\n    if (commandConfig instanceof Command) {\n        // If commandConfig is an instance of Command class, it's valid\n        return true;\n    } else if (typeof commandConfig === 'object' && commandConfig !== null) {\n        // If commandConfig is an object representation, we'll check its properties\n        if (commandConfig.hasOwnProperty('commandId') && commandConfig.hasOwnProperty('action')) {\n            // Optionally, add specific validation logic for command configuration here\n            return true; // All checks passed\n        }\n    }\n    return false; // Invalid command configuration\n}\n\nclass DeviceManager {\n    constructor(mapping = {}) {\n        this.devices = mapping;\n    }\n\n    setDevice(device_id, data) {\n        this.devices[device_id] = data;\n    }\n\n    getDevice(device_id) {\n        return this.devices[device_id];\n    }\n\n    removeDevice(device_id) {\n        if (this.devices.hasOwnProperty(device_id)) {\n            delete this.devices[device_id];\n        }\n    }\n\n    getDevices() {\n        return this.devices;\n    }\n}\n\nclass DebounceTimerManager {\n    constructor() {\n        this.timers = {};\n    }\n\n    createTimer(attributeValues, debounceTimers, callback, delay) {\n        let nestedObject = debounceTimers;\n        for (const attrValue of attributeValues) {\n            nestedObject[attrValue] = nestedObject[attrValue] || {};\n            nestedObject = nestedObject[attrValue];\n        }\n        if (!nestedObject.hasOwnProperty('timer')) {\n            nestedObject.timer = setTimeout(callback, delay);\n        }\n    }\n\n    updateTimer(attributeValues, debounceTimers, callback, delay) {\n        this.clearTimer(attributeValues, debounceTimers);\n        this.createTimer(attributeValues, debounceTimers, callback, delay);\n    }\n\n    clearTimer(attributeValues, debounceTimers) {\n        let nestedObject = debounceTimers;\n        for (const attrValue of attributeValues) {\n            if (!nestedObject[attrValue]) {\n                return;\n            }\n            nestedObject = nestedObject[attrValue];\n        }\n        if (nestedObject.timer) {\n            clearTimeout(nestedObject.timer);\n            delete nestedObject.timer;\n        }\n    }\n}\n\nclass WaitTimerManager {\n    constructor() {\n        this.timers = {};\n        this.callbacks = {}; // Store callbacks for each event or condition\n        this.checkInterval = 1000; // Interval in milliseconds for checking existence\n    }\n\n    // Create a timer that waits for the item to exist\n    createWaitTimer(item, callback, timeout = null) {\n        // Check if the item already has callbacks registered\n        if (!this.callbacks[item]) {\n            this.callbacks[item] = [];\n        }\n\n        // Add the new callback to the list of callbacks for this item\n        this.callbacks[item].push(callback);\n\n        // If the timer doesn't exist, create it\n        if (!this.timers[item]) {\n            if (timeout !== null) {\n                // If timeout is provided, clear the timer after the specified duration\n                this.timers[item] = setTimeout(() => {\n                    this.clearWaitTimer(item);\n                    this.invokeCallbacks(item, new Error(`Timeout waiting for ${item}`));\n                }, timeout);\n            }\n\n            // Check for the existence of the item periodically\n            this.checkExistence(item);\n        }\n    }\n\n    // Check for the existence of the item periodically\n    checkExistence(item) {\n        const interval = setInterval(() => {\n            if (global.get(item) !== undefined) {\n                clearInterval(interval);\n                this.invokeCallbacks(item, null); // Item found\n            }\n        }, this.checkInterval);\n    }\n\n    // Invoke all callbacks associated with the item\n    invokeCallbacks(item, error) {\n        if (this.callbacks[item]) {\n            this.callbacks[item].forEach(callback => {\n                callback(error);\n            });\n            delete this.callbacks[item]; // Remove the callbacks for this item\n        }\n    }\n\n    // Clear the timer associated with the item\n    clearWaitTimer(item) {\n        if (this.timers[item]) {\n            clearTimeout(this.timers[item]);\n            delete this.timers[item];\n        }\n    }\n}\n\n// Create a singleton instance of WaitTimerManager\nconst waitTimerManager = new WaitTimerManager();\n\nclass Person {\n    constructor(person_object) {\n        // Assign properties from the personObj parameter\n        this.entityId = person_object.entity_id;\n        this.oldState = person_object.old_state;\n        this.newState = person_object.new_state;\n    }\n\n    isPresent() {\n        return this.newState.state !== 'not_home';\n    }\n\n    getId() {\n        return this.newState.attributes.id;\n    }\n\n    // Other methods for manipulating the person object can be added here\n}\n\nclass MotionEvent {\n    constructor(sensor_id, location, timestamp, state = \"on\", attr = {}) {\n        this.sensor_id = sensor_id;\n        this.location = location;\n        this.timestamp = timestamp;\n        // Check if state is passed as an attribute\n        if (typeof state === \"object\") {\n            attr = state; // Treat state as part of the attributes\n            state = \"on\"; // Default state if not provided separately\n        }\n        this.state = state;\n        // Spread optional attributes onto the class instance\n        Object.assign(this, attr);\n    }\n}\n\n// Motion detection handler function\nfunction motionDetectionHandler(event_data) {\n\n    if (!event_data) {\n        const message = \"[ERROR]: Missing motion event data\";\n        node.warn(message);\n        node.status(status(message, { fill: \"red\" }).payload);\n        return null;\n    }\n\n    const sensor_id = event_data.entity_id;\n\n    return getEntity(sensor_id)\n        .then(entity => {\n            // If an entity_id was found, get location/area_id\n            const location = entity.area_id;\n\n            // Create MotionEvent object\n            const motion_event_obj = new MotionEvent(\n                sensor_id, // entity\n                location, // area_id\n                event_data.last_changed, // timestamp\n                //{ last_updated: event_data.last_updated }\n                event_data\n            );\n            // Call the registered callback function on the motion sensor port with the event data\n            return motionSensorPort(motion_event_obj);\n        })\n        .catch(error => {\n            // Handle any errors thrown by getEntity\n            const message = `[ERROR]: ${error.message}`;\n            node.warn(message);\n            node.status(status(message, { fill: \"red\" }).payload);\n            return null;\n        });\n\n}\n\n// Occupancy Repository\nclass OccupancyRepository {\n    static getObject() {\n        return global.get(OCCUPANCY.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(OCCUPANCY.OBJECT, value);\n    }\n}\n\n// Presence Repository\nclass PresenceRepository {\n    static getObject() {\n        return global.get(PRESENCE.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(PRESENCE.OBJECT, value);\n    }\n}\n\n// Source Repository\nclass SourceRepository {\n    static getObject() {\n        return global.get(SOURCE.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(SOURCE.OBJECT, value);\n    }\n}\n\n// Entities Repository\nclass EntitiesRepository {\n    static getObject() {\n        return global.get(ENTITIES.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(ENTITIES.OBJECT, value);\n    }\n}\n\n// Areas Repository\nclass AreasRepository {\n    static getObject() {\n        return global.get(AREAS.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(AREAS.OBJECT, value);\n    }\n}\n\n// Devices Repository\nclass DevicesRepository {\n    static getObject() {\n        return global.get(DEVICES.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(DEVICES.OBJECT, value);\n    }\n}\n\nfunction motionSensorPort(motion_event) {\n    try {\n        const status = `Motion detected [${motion_event.state}] at [${motion_event.location}: ${motion_event.sensor_id}] at [${new Date(motion_event.timestamp)}]`;\n        // Core domain logic for processing motion events\n\n        return {motion_event, status};\n    } catch (error) {\n        // If an error occurs during processing, return the error message\n        return {motion_event, status:`Error processing motion event: ${error.message}`}\n    }\n}\n\n// General\nglobal.set(`${object_id}healthCheck`, healthCheck);\nglobal.set(`${object_id}round`, round);\nglobal.set(`${object_id}getGlobalID`, getGlobalID);\nglobal.set(`${object_id}exists`, exists);\nglobal.set(`${object_id}status`, status);\nglobal.set(`${object_id}setAttribute`, setAttribute);\nglobal.set(`${object_id}append`, append);\nglobal.set(`${object_id}abate`, abate);\nglobal.set(`${object_id}getFileNameFromPath`, getFileNameFromPath);\nglobal.set(`${object_id}mapArrayToDict`, mapArrayToDict);\nglobal.set(`${object_id}currentState`, currentState);\nglobal.set(`${object_id}castToArray`, castToArray);\nglobal.set(`${object_id}getEventAttributes`, getEventAttributes);\nglobal.set(`${object_id}getEntity`, getEntity);\nglobal.set(`${object_id}waitForGlobalContext`, waitForGlobalContext);\nglobal.set(`${object_id}getGlobalAsync`, getGlobalAsync);\n\n// API\nglobal.set(`${object_id}createResponseObject`, createResponseObject);\n\n// .yaml template generation\nglobal.set(`${object_id}generateToggleSwitchValueTemplate`, generateToggleSwitchValueTemplate);\nglobal.set(`${object_id}generateTemplateSwitchObject`, generateTemplateSwitchObject);\nglobal.set(`${object_id}generateYamlTemplateObject`, generateYamlTemplateObject);\nglobal.set(`${object_id}addEntityToTemplateObject`, addEntityToTemplateObject);\nglobal.set(`${object_id}createTurnOnOffObject`, createTurnOnOffObject);\nglobal.set(`${object_id}createIconTemplate`, createIconTemplate);\n\n// RemoteInterface\nglobal.set(`${object_id}RemoteInterface`, RemoteInterface);\nglobal.set(`${object_id}Remote`, Remote);\nglobal.set(`${object_id}Button`, Button);\nglobal.set(`${object_id}Command`, Command);\n\n// Device Manager\nglobal.set(`${object_id}DeviceManager`, DeviceManager);\n\n// Timer Managers\nglobal.set(`${object_id}DebounceTimerManager`, DebounceTimerManager);\nglobal.set(`${object_id}WaitTimerManager`, WaitTimerManager);\n\n// Person\nglobal.set(`${object_id}Person`, Person);\n\n// Domains\nglobal.set(`${object_id}MotionEvent`, MotionEvent);\nglobal.set(`${object_id}motionDetectionHandler`, motionDetectionHandler);\nglobal.set(`${object_id}OccupancyRepository`, OccupancyRepository);\nglobal.set(`${object_id}PresenceRepository`, PresenceRepository);\nglobal.set(`${object_id}SourceRepository`, SourceRepository);\nglobal.set(`${object_id}EntitiesRepository`, EntitiesRepository);\nglobal.set(`${object_id}AreasRepository`, AreasRepository);\nglobal.set(`${object_id}DevicesRepository`, DevicesRepository);\n\n// Ports\nconst ports = {\n    motionSensorPort\n};\nglobal.set(`${object_id}motionSensorPort`, motionSensorPort);\n\n// Adapters\nconst adapters = {};\n\n// Domain\nconst domain = {\n    MotionEvent,\n    motionDetectionHandler,\n    OccupancyRepository,\n    PresenceRepository,\n\n};\n\n// General\nconst util = {};\n\nconst utils = {\n    adapters,\n    domain,\n    ports,\n    util\n};\n\nvar loaded = false;\nvar gc = global.keys();\n\n// Check if utils object is loaded\nfor (let i = 0; i < gc.length; i++) {\n\n    if (gc[i] === UTILS.OBJECT) loaded = true;\n\n}\n\nglobal.set(`${SOURCE.REPOSITORY}${UTILS.OBJECT}`, utils);\n\n// Return loaded status\nif (loaded) return status(`Utility Functions Loaded [${UTILS.OBJECT}]`);\n\n// Return non-loaded status\nreturn status(`Utility Functions Not loaded [${UTILS.OBJECT}]`);","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":120,"y":500,"wires":[[]]},{"id":"90bc71eda9d6d26a","type":"function","z":"f9586397.5973","name":"Utility Functions","func":"/** Utility Functions **/\n\n// Default to utils object if no UTIL_GC environment variable passed\nconst UTILS = getPathObject(env.get(\"UTIL_GC\") || \"utils\");\nconst object_id = UTILS.REPOSITORY;\n\nconst SOURCE = getPathObject(env.get(\"GLOBAL_ID\") || \"system\");\n\nconst ENTITIES = getPathObject(`${SOURCE.REPOSITORY}entities`);\nconst AREAS = getPathObject(`${SOURCE.REPOSITORY}areas`);\nconst DEVICES = getPathObject(`${SOURCE.REPOSITORY}devices`);\nconst OCCUPANCY = getPathObject(`${SOURCE.REPOSITORY}occupancy`);\nconst PRESENCE = getPathObject(`${SOURCE.REPOSITORY}presence`);\n\n// For testing / debugging purposes\nfunction healthCheck () {\n    return true;\n}\n\n// For global context path setup\nfunction getPathObject(path) {\n\n    return {\n        REPOSITORY: append(path, \".\"),\n        OBJECT: abate(path, \".\")\n    };\n}\n\n// Rounding function with precision\nfunction round(value, precision) {\n\n    // Return raw value if no precision passed\n    if (!exists(precision)) return value;\n\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(value * multiplier) / multiplier;\n}\n\n// Check if entity_id was passed, and remove domain\nfunction getGlobalID(globalID) {\n\n    // If an entity_id was passed, remove domain\n    if (exists(globalID) && globalID.includes(\".\")) {\n\n        globalID = globalID.split(\".\")[1];\n\n    }\n\n    // Return global ID\n    return globalID;\n}\n\n// Check if a value exists\nfunction exists(value) {\n\n    var valueType = typeof value;\n\n    // Check for empty string\n    if (valueType === \"string\") {\n        if (value == \"\" || (value.length == 0)) return false;\n    }\n\n    // null check\n    if (value === null) return false;\n\n    // undefined check\n    if (valueType === \"undefined\") return false;\n\n    // Empty object check\n    if (valueType == \"object\") {\n        if (Object.keys(value).length === 0) return false;\n    }\n\n    //return value != (\"\" || undefined || null || (value.length == 0));\n    return true;\n\n}\n\n// Create a new object and assign message to payload\nfunction status(message, properties = { fill: \"green\", shape: \"dot\" }) {\n    return {\n        \"payload\": {\n            ...properties,\n            text: message\n        }\n    };\n}\n\n// Create a new object and assign message to payload (finish for me pls <3)\nfunction statusOld(message) {\n    return { \"payload\": message };\n}\n\n// Sets an object attribute to a given value\nfunction setAttribute (property, attribute, value) {\n    \n    // Check if msg property is an object\n    if (!(typeof property === 'object')) {\n        property = {};\n    }\n    \n    // If attribute not passed, default to payload\n    if (!exists(attribute)) {\n        attribute = \"payload\";\n    }\n\n    // Set value\n    property[attribute] = value;\n\n    return property;\n\n}\n\n// Append character to end of string if not present\nfunction append(value, character) {\n\n    // Check if end of string matches character\n    if (value.charAt(value.length - character.length) !== character) {\n\n        // Append character if not found\n        value = value + character;\n    }\n\n    return value;\n\n}\n\n// Remove character from end of string\nfunction abate(value, character) {\n\n    // Check if end of string matches character(s) \n    if (value.charAt(value.length - character.length) === character) {\n\n        // Abate character if found\n        value = value.substring(0, value.length - character.length);\n    }\n\n    return value;\n\n}\n\n// Cast Object to array\nfunction castToArray(value) {\n    return (Array.isArray(value)) ? value : [value];\n}\n\n// Function to get attribute values from event data\nfunction getEventAttributes(event, attributes) {\n    return attributes.map(attr => event[attr]);\n}\n\n// Function to get an entity from an entities object\nfunction getEntity(entity_id) {\n    return new Promise((resolve, reject) => {\n\n        // Timeout value in milliseconds\n        const TIMEOUT = 10000; \n\n        const entities = global.get(ENTITIES.OBJECT);\n        //const entities = EntitiesRepository.getObject();\n\n        // Check if entities are already available\n        if (exists(entities)) {\n            resolve(entities[entity_id]);\n        } else {\n            const waitManager = new WaitTimerManager();\n\n            // Function to handle timer callback\n            const timerCallback = function (error) {\n                if (error) {\n                    // Timeout occurred\n                    reject(new Error(`Entities not loaded within ${TIMEOUT} ms`));\n                } else {\n                    // Re-fetch the entities object and resolve the promise\n                    const loaded_entities = global.get(ENTITIES.OBJECT);\n                    //const loaded_entities = EntitiesRepository.getObject();\n                    if (loaded_entities) {\n                        // Fetch the entity from the entities object\n                        resolve(loaded_entities[entity_id]);\n                        // Cancel the wait timer\n                        waitManager.clearWaitTimer(ENTITIES.OBJECT); \n                    }\n                    // Entities object not available yet, retrying...\n                }\n            };\n\n            // Create wait timer\n            waitManager.createWaitTimer(ENTITIES.OBJECT, timerCallback, TIMEOUT);\n            node.warn(\"Waiting for entities...\");\n        }\n    });\n}\n\n// Function to get an object from global context\nfunction waitForGlobalContext(global_id, TIMEOUT = 10000) {\n    return new Promise((resolve, reject) => {\n\n        const object_value = global.get(global_id);\n\n        // Check if value is already available\n        if (exists(object_value)) {\n            resolve(object_value);\n        } else {\n            const waitManager = new WaitTimerManager();\n\n            // Function to handle timer callback\n            const timerCallback = function (error) {\n                if (error) {\n                    // Timeout occurred\n                    reject(new Error(`Object not loaded within ${TIMEOUT} ms`));\n                } else {\n                    // Re-fetch the object and resolve the promise\n                    const loaded_object_value = global.get(global_id);\n                    node.warn(`Reloading object: ${loaded_object_value}`);\n                    if (loaded_object_value) {\n                        node.warn(`Object loaded (${global_id}): ${loaded_object_value}`);\n                        resolve(loaded_object_value);\n                        // Cancel the wait timer\n                        waitManager.clearWaitTimer(global_id);\n                    }\n                    node.warn(`Object not available yet, retrying...`);\n                }\n            };\n\n            // Create wait timer\n            waitManager.createWaitTimer(global_id, timerCallback, TIMEOUT);\n            node.warn(\"Waiting for object...\");\n        }\n    });\n}\n\nfunction getGlobalAsync(globalId, timeout = 10000) {\n    return new Promise((resolve, reject) => {\n        const interval = setInterval(() => {\n            const obj = global.get(globalId);\n            if (obj !== undefined) {\n                clearInterval(interval);\n                resolve(obj);\n            }\n        }, 1000); // Check every second\n\n        setTimeout(() => {\n            clearInterval(interval);\n            reject(new Error(`Timeout reached while waiting for global context object: ${globalId}`));\n        }, timeout);\n    });\n}\n\n\n//**API **//\n\nfunction createResponseObject(response_code, message) {\n    return {\n        \"response_code\": response_code,\n        \"data\": message\n    }\n}\n\nfunction generateToggleSwitchValueTemplate(toggleEntityId, triggerEntityId, triggerEntityState) {\n    return `{% if is_state('${toggleEntityId}', 'on') %}\n        {{ is_state('${triggerEntityId}', '${triggerEntityState}') }}\n        {% else %}\n        {{ is_state('${toggleEntityId}', 'on') }}\n        {% endif %}`;\n}\n\nfunction generateTemplateSwitchObject(switchId, friendlyName, valueTemplate, turnOnAction, turnOffAction, iconTemplate) {\n    const switchObject = {\n        [switchId]: {\n            friendly_name: friendlyName,\n            value_template: valueTemplate,\n            turn_on: [turnOnAction],\n            turn_off: [turnOffAction],\n            icon_template: iconTemplate\n        }\n    };\n    return switchObject;\n}\n\nfunction generateYamlTemplateObject(entity_type) {\n    const yamlObject = {\n        platform: 'template',\n        [entity_type]: {}\n    };\n    return [yamlObject];\n}\n\nfunction addEntityToTemplateObject(yamlObject, entity_type, entity) {\n    yamlObject[0][entity_type] = {\n        ...yamlObject[0][entity_type],\n        ...entity\n    };\n    return yamlObject;\n}\n\nfunction createTurnOnOffObject(service, data = {}) {\n    return {\n        turn_on: [\n            {\n                service: service,\n                ...data.turn_on // Spread additional turn_on data if provided\n            }\n        ],\n        turn_off: [\n            {\n                service: service,\n                ...data.turn_off // Spread additional turn_off data if provided\n            }\n        ]\n    };\n}\n\nfunction createIconTemplate(onStateIcon, offStateIcon = null, triggerEntityId = null, triggerEntityState = null) {\n    if (!offStateIcon) {\n        return `mdi:${onStateIcon}`;\n    } else {\n        return `{% if is_state('${triggerEntityId}', '${triggerEntityState}') %}\n            mdi:${onStateIcon}\n        {% else %}\n            mdi:${offStateIcon}\n        {% endif %}`;\n    }\n}\n\nfunction getFileNameFromPath(filePath) {\n    const parts = filePath.split('/');\n    return parts[parts.length - 1];\n}\n\nfunction mapArrayToDict(entities, key) {\n    const entityDict = {};\n\n    entities.forEach(entity => {\n        entityDict[entity[key]] = entity;\n    });\n\n    return entityDict;\n}\n\nfunction currentState(entityId) {\n    return global.get(\"homeassistant.homeAssistant.states\")[entityId];\n}\n\nclass Remote {\n    constructor(remoteId, buttons = {}) {\n        this.remoteId = remoteId;\n        this.buttons = {};\n\n        // Check if buttons is an instance of Remote, if not, convert each entry to a Button instance\n        if (!(buttons instanceof Remote)) {\n            for (const buttonId in buttons) {\n                if (buttons.hasOwnProperty(buttonId)) {\n                    this.addButton(buttonId, buttons[buttonId]);\n                }\n            }\n        }\n    }\n\n    addButton(buttonId, sourceButton = null) {\n        const button = sourceButton instanceof Button ? sourceButton : new Button(buttonId, sourceButton);\n        this.buttons[buttonId] = button;\n        return button;\n    }\n\n    getId() {\n        return this.remoteId;\n    }\n\n    getObject() {\n        const remoteObject = {};\n        Object.keys(this.buttons).forEach(buttonId => {\n            remoteObject[buttonId] = this.buttons[buttonId].getObject();\n        });\n        return remoteObject;\n    }\n}\n\nclass Button {\n    constructor(buttonId, commands = {}) {\n        this.buttonId = buttonId;\n        this.commands = {};\n\n        // Check if commands is an instance of Button, if not, convert each entry to a Command instance\n        if (!(commands instanceof Button)) {\n            for (const commandId in commands) {\n                if (commands.hasOwnProperty(commandId)) {\n                    this.addCommand(commandId, commands[commandId]);\n                }\n            }\n        }\n    }\n\n    addCommand(commandId, sourceCommand = null) {\n        const command = sourceCommand instanceof Command ? sourceCommand : new Command(commandId, sourceCommand);\n        this.commands[commandId] = command;\n        return command;\n    }\n\n    getId() {\n        return this.buttonId;\n    }\n\n    getObject() {\n        const buttonObject = {};\n        Object.keys(this.commands).forEach(commandId => {\n            buttonObject[commandId] = this.commands[commandId].getObject();\n        });\n        return buttonObject;\n    }\n}\n\nclass Command {\n    constructor(commandId, action = {}) {\n        this.commandId = commandId;\n        this.action = action;\n    }\n\n    getId() {\n        return this.commandId;\n    }\n\n    getObject() {\n        return this.action;\n    }\n}\n\n\nclass RemoteInterface {\n    constructor(remoteConfig = {}) {\n        this.remotes = {};\n        if (remoteConfig instanceof Remote) {\n            this.setRemote(remoteConfig.getId(), remoteConfig);\n        } else {\n            const remotes = remoteConfig.remotes || {};\n            Object.keys(remotes).forEach(remoteId => {\n                this.setRemote(remoteId, remotes[remoteId]);\n            });\n        }\n    }\n\n\n    setRemote(remoteId, sourceRemote = null) {\n        if (sourceRemote instanceof Remote) {\n            this.remotes[remoteId] = sourceRemote;\n        } else if (sourceRemote) {\n\n            if (!validateRemote(sourceRemote)) {\n                throw new Error('Invalid remote configuration');\n            }\n            this.remotes[remoteId] = new Remote(remoteId, sourceRemote);\n        } else {\n            this.remotes[remoteId] = new Remote(remoteId);\n        }\n        return this.remotes[remoteId];\n    }\n\n    setButton(remoteId, buttonId, sourceButton = null) {\n        if (!this.remotes[remoteId]) {\n            this.setRemote(remoteId); // Ensure remote exists before setting button\n        }\n        const button = this.remotes[remoteId].addButton(buttonId, sourceButton);\n        return button;\n    }\n\n\n    setCommand(remoteId, buttonId, commandId, sourceCommand = null) {\n        if (!this.remotes[remoteId]) {\n            this.setRemote(remoteId);\n        }\n        if (!this.remotes[remoteId].buttons[buttonId]) {\n            this.setButton(remoteId, buttonId);\n        }\n        const button = this.remotes[remoteId].buttons[buttonId];\n        const command = button.addCommand(commandId, sourceCommand);\n        return command;\n    }\n\n    getCommand(remoteId, buttonId, commandId) {\n        const remote = this.remotes[remoteId];\n\n        if (!remote) {\n            throw new Error(`Remote not found for ID ${remoteId}`);\n        }\n\n        const button = remote.buttons[buttonId];\n        if (!button) {\n            throw new Error(`Button not found for ID ${buttonId}`);\n        }\n\n        const command = button.commands[commandId];\n        if (!command) {\n            throw new Error(`Command not found for ID ${commandId}`);\n        }\n\n        return command;\n    }\n\n    getRemoteIds() {\n        return Object.keys(this.remotes);\n    }\n\n    // Ignore this, it's for debugging\n    getButtonIds2(remoteId) {\n        if (this.remotes[remoteId]) {\n            return Object.keys(this.remotes[remoteId].buttons);\n        }\n        return [];\n    }\n\n    getButtonIds(remoteId) {\n        if (this.remotes[remoteId]) {\n            if (this.remotes[remoteId] instanceof Button) {\n                // If the value is an instance of Button, return its ID\n                return [this.remotes[remoteId].getId()];\n            } else {\n                // Otherwise, assume it's an object with button IDs as keys\n                return Object.keys(this.remotes[remoteId]);\n            }\n        }\n        return [];\n    }\n\n    getCommandIds(remoteId, buttonId) {\n        if (this.remotes[remoteId] && this.remotes[remoteId].buttons[buttonId]) {\n            return Object.keys(this.remotes[remoteId].buttons[buttonId].commands);\n        }\n        return [];\n    }\n\n    getObject() {\n        return {\n            remotes: this.remotes\n        };\n    }\n}\n\n// Validation functions\nfunction validateRemote(remoteConfig) {\n    if (remoteConfig instanceof Remote) {\n        // If remoteConfig is already an instance of Remote, it's valid\n        return true;\n    } else if (typeof remoteConfig === 'object' && remoteConfig !== null) {\n        const remoteInstance = new Remote('remoteId');\n\n        // Iterate over each button in the remote\n        Object.keys(remoteConfig).forEach(buttonId => {\n            const commandConfigs = remoteConfig[buttonId];\n            const buttonInstance = new Button(buttonId);\n\n            // Iterate over each command in the button\n            Object.keys(commandConfigs).forEach(commandId => {\n                const commandInstance = new Command(commandId, commandConfigs[commandId]);\n\n                // Add the command to the button\n                buttonInstance.addCommand(commandId, commandInstance);\n            });\n\n            // Add the button to the remote\n            remoteInstance.addButton(buttonId, buttonInstance);\n        });\n\n        // Validate the remote instance\n        const isValid = validateRemote(remoteInstance);\n        return isValid;\n    } else {\n        return false; // Invalid remote configuration\n    }\n}\n\n\n\nfunction validateButton(buttonConfig) {\n    if (buttonConfig instanceof Button) {\n        // If buttonConfig is an instance of Button class, we'll validate its commands\n        for (const commandId in buttonConfig.commands) {\n            if (!buttonConfig.commands.hasOwnProperty(commandId)) {\n                continue;\n            }\n            const command = buttonConfig.commands[commandId];\n            if (!(command instanceof Command)) {\n                return false; // Invalid command within the button\n            }\n            // Optionally, add specific validation logic for command configuration here\n        }\n        return true; // All checks passed\n    } else if (typeof buttonConfig === 'object' && buttonConfig !== null && buttonConfig.hasOwnProperty('commands')) {\n        // If buttonConfig is an object representation, we'll recursively call validateCommand for each command\n        for (const commandId in buttonConfig.commands) {\n            if (!buttonConfig.commands.hasOwnProperty(commandId)) {\n                continue;\n            }\n            if (!validateCommand(buttonConfig.commands[commandId])) {\n                return false; // Invalid command configuration\n            }\n        }\n        return true; // All checks passed\n    } else {\n        return false; // Invalid button configuration\n    }\n}\n\nfunction validateCommand(commandConfig) {\n    if (commandConfig instanceof Command) {\n        // If commandConfig is an instance of Command class, it's valid\n        return true;\n    } else if (typeof commandConfig === 'object' && commandConfig !== null) {\n        // If commandConfig is an object representation, we'll check its properties\n        if (commandConfig.hasOwnProperty('commandId') && commandConfig.hasOwnProperty('action')) {\n            // Optionally, add specific validation logic for command configuration here\n            return true; // All checks passed\n        }\n    }\n    return false; // Invalid command configuration\n}\n\nclass DeviceManager {\n    constructor(mapping = {}) {\n        this.devices = mapping;\n    }\n\n    setDevice(device_id, data) {\n        this.devices[device_id] = data;\n    }\n\n    getDevice(device_id) {\n        return this.devices[device_id];\n    }\n\n    removeDevice(device_id) {\n        if (this.devices.hasOwnProperty(device_id)) {\n            delete this.devices[device_id];\n        }\n    }\n\n    getDevices() {\n        return this.devices;\n    }\n}\n\nclass DebounceTimerManager {\n    constructor() {\n        this.timers = {};\n    }\n\n    createTimer(attributeValues, debounceTimers, callback, delay) {\n        let nestedObject = debounceTimers;\n        for (const attrValue of attributeValues) {\n            nestedObject[attrValue] = nestedObject[attrValue] || {};\n            nestedObject = nestedObject[attrValue];\n        }\n        if (!nestedObject.hasOwnProperty('timer')) {\n            nestedObject.timer = setTimeout(callback, delay);\n        }\n    }\n\n    updateTimer(attributeValues, debounceTimers, callback, delay) {\n        this.clearTimer(attributeValues, debounceTimers);\n        this.createTimer(attributeValues, debounceTimers, callback, delay);\n    }\n\n    clearTimer(attributeValues, debounceTimers) {\n        let nestedObject = debounceTimers;\n        for (const attrValue of attributeValues) {\n            if (!nestedObject[attrValue]) {\n                return;\n            }\n            nestedObject = nestedObject[attrValue];\n        }\n        if (nestedObject.timer) {\n            clearTimeout(nestedObject.timer);\n            delete nestedObject.timer;\n        }\n    }\n}\n\nclass WaitTimerManager {\n    constructor() {\n        this.timers = {};\n        this.callbacks = {}; // Store callbacks for each event or condition\n        this.checkInterval = 1000; // Interval in milliseconds for checking existence\n    }\n\n    // Create a timer that waits for the item to exist\n    createWaitTimer(item, callback, timeout = null) {\n        // Check if the item already has callbacks registered\n        if (!this.callbacks[item]) {\n            this.callbacks[item] = [];\n        }\n\n        // Add the new callback to the list of callbacks for this item\n        this.callbacks[item].push(callback);\n\n        // If the timer doesn't exist, create it\n        if (!this.timers[item]) {\n            if (timeout !== null) {\n                // If timeout is provided, clear the timer after the specified duration\n                this.timers[item] = setTimeout(() => {\n                    this.clearWaitTimer(item);\n                    this.invokeCallbacks(item, new Error(`Timeout waiting for ${item}`));\n                }, timeout);\n            }\n\n            // Check for the existence of the item periodically\n            this.checkExistence(item);\n        }\n    }\n\n    // Check for the existence of the item periodically\n    checkExistence(item) {\n        const interval = setInterval(() => {\n            if (global.get(item) !== undefined) {\n                clearInterval(interval);\n                this.invokeCallbacks(item, null); // Item found\n            }\n        }, this.checkInterval);\n    }\n\n    // Invoke all callbacks associated with the item\n    invokeCallbacks(item, error) {\n        if (this.callbacks[item]) {\n            this.callbacks[item].forEach(callback => {\n                callback(error);\n            });\n            delete this.callbacks[item]; // Remove the callbacks for this item\n        }\n    }\n\n    // Clear the timer associated with the item\n    clearWaitTimer(item) {\n        if (this.timers[item]) {\n            clearTimeout(this.timers[item]);\n            delete this.timers[item];\n        }\n    }\n}\n\n// Create a singleton instance of WaitTimerManager\nconst waitTimerManager = new WaitTimerManager();\n\nclass Person {\n    constructor(person_object) {\n        // Assign properties from the personObj parameter\n        this.entityId = person_object.entity_id;\n        this.oldState = person_object.old_state;\n        this.newState = person_object.new_state;\n    }\n\n    isPresent() {\n        return this.newState.state !== 'not_home';\n    }\n\n    getId() {\n        return this.newState.attributes.id;\n    }\n\n    // Other methods for manipulating the person object can be added here\n}\n\nclass MotionEvent {\n    constructor(sensor_id, location, timestamp, state = \"on\", attr = {}) {\n        this.sensor_id = sensor_id;\n        this.location = location;\n        this.timestamp = timestamp;\n        // Check if state is passed as an attribute\n        if (typeof state === \"object\") {\n            attr = state; // Treat state as part of the attributes\n            state = \"on\"; // Default state if not provided separately\n        }\n        this.state = state;\n        // Spread optional attributes onto the class instance\n        Object.assign(this, attr);\n    }\n}\n\n// Motion detection handler function\nfunction motionDetectionHandler(event_data) {\n\n    if (!event_data) {\n        const message = \"[ERROR]: Missing motion event data\";\n        node.warn(message);\n        node.status(status(message, { fill: \"red\" }).payload);\n        return null;\n    }\n\n    const sensor_id = event_data.entity_id;\n\n    return getEntity(sensor_id)\n        .then(entity => {\n            // If an entity_id was found, get location/area_id\n            const location = entity.area_id;\n\n            // Create MotionEvent object\n            const motion_event_obj = new MotionEvent(\n                sensor_id, // entity\n                location, // area_id\n                event_data.last_changed, // timestamp\n                //{ last_updated: event_data.last_updated }\n                event_data\n            );\n            // Call the registered callback function on the motion sensor port with the event data\n            return motionSensorPort(motion_event_obj);\n        })\n        .catch(error => {\n            // Handle any errors thrown by getEntity\n            const message = `[ERROR]: ${error.message}`;\n            node.warn(message);\n            node.status(status(message, { fill: \"red\" }).payload);\n            return null;\n        });\n\n}\n\n// Occupancy Repository\nclass OccupancyRepository {\n    static getObject() {\n        return global.get(OCCUPANCY.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(OCCUPANCY.OBJECT, value);\n    }\n}\n\n// Presence Repository\nclass PresenceRepository {\n    static getObject() {\n        return global.get(PRESENCE.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(PRESENCE.OBJECT, value);\n    }\n}\n\n// Source Repository\nclass SourceRepository {\n    static getObject() {\n        return global.get(SOURCE.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(SOURCE.OBJECT, value);\n    }\n}\n\n// Entities Repository\nclass EntitiesRepository {\n    static getObject() {\n        return global.get(ENTITIES.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(ENTITIES.OBJECT, value);\n    }\n}\n\n// Areas Repository\nclass AreasRepository {\n    static getObject() {\n        return global.get(AREAS.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(AREAS.OBJECT, value);\n    }\n}\n\n// Devices Repository\nclass DevicesRepository {\n    static getObject() {\n        return global.get(DEVICES.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(DEVICES.OBJECT, value);\n    }\n}\n\nfunction motionSensorPort(motion_event) {\n    try {\n        const status = `Motion detected [${motion_event.state}] at [${motion_event.location}: ${motion_event.sensor_id}] at [${new Date(motion_event.timestamp)}]`;\n        // Core domain logic for processing motion events\n\n        return {motion_event, status};\n    } catch (error) {\n        // If an error occurs during processing, return the error message\n        return {motion_event, status:`Error processing motion event: ${error.message}`}\n    }\n}\n\n// General\nglobal.set(`${object_id}healthCheck`, healthCheck);\nglobal.set(`${object_id}round`, round);\nglobal.set(`${object_id}getGlobalID`, getGlobalID);\nglobal.set(`${object_id}exists`, exists);\nglobal.set(`${object_id}status`, status);\nglobal.set(`${object_id}setAttribute`, setAttribute);\nglobal.set(`${object_id}append`, append);\nglobal.set(`${object_id}abate`, abate);\nglobal.set(`${object_id}getFileNameFromPath`, getFileNameFromPath);\nglobal.set(`${object_id}mapArrayToDict`, mapArrayToDict);\nglobal.set(`${object_id}currentState`, currentState);\nglobal.set(`${object_id}castToArray`, castToArray);\nglobal.set(`${object_id}getEventAttributes`, getEventAttributes);\nglobal.set(`${object_id}getEntity`, getEntity);\nglobal.set(`${object_id}waitForGlobalContext`, waitForGlobalContext);\nglobal.set(`${object_id}getGlobalAsync`, getGlobalAsync);\n\n// API\nglobal.set(`${object_id}createResponseObject`, createResponseObject);\n\n// .yaml template generation\nglobal.set(`${object_id}generateToggleSwitchValueTemplate`, generateToggleSwitchValueTemplate);\nglobal.set(`${object_id}generateTemplateSwitchObject`, generateTemplateSwitchObject);\nglobal.set(`${object_id}generateYamlTemplateObject`, generateYamlTemplateObject);\nglobal.set(`${object_id}addEntityToTemplateObject`, addEntityToTemplateObject);\nglobal.set(`${object_id}createTurnOnOffObject`, createTurnOnOffObject);\nglobal.set(`${object_id}createIconTemplate`, createIconTemplate);\n\n// RemoteInterface\nglobal.set(`${object_id}RemoteInterface`, RemoteInterface);\nglobal.set(`${object_id}Remote`, Remote);\nglobal.set(`${object_id}Button`, Button);\nglobal.set(`${object_id}Command`, Command);\n\n// Device Manager\nglobal.set(`${object_id}DeviceManager`, DeviceManager);\n\n// Timer Managers\nglobal.set(`${object_id}DebounceTimerManager`, DebounceTimerManager);\nglobal.set(`${object_id}WaitTimerManager`, WaitTimerManager);\n\n// Person\nglobal.set(`${object_id}Person`, Person);\n\n// Domains\nglobal.set(`${object_id}MotionEvent`, MotionEvent);\nglobal.set(`${object_id}motionDetectionHandler`, motionDetectionHandler);\nglobal.set(`${object_id}OccupancyRepository`, OccupancyRepository);\nglobal.set(`${object_id}PresenceRepository`, PresenceRepository);\nglobal.set(`${object_id}SourceRepository`, SourceRepository);\nglobal.set(`${object_id}EntitiesRepository`, EntitiesRepository);\nglobal.set(`${object_id}AreasRepository`, AreasRepository);\nglobal.set(`${object_id}DevicesRepository`, DevicesRepository);\n\n// Ports\nconst ports = {\n    motionSensorPort\n};\nglobal.set(`${object_id}motionSensorPort`, motionSensorPort);\n\n// Adapters\nconst adapters = {};\n\n// Domain\nconst domain = {\n    MotionEvent,\n    motionDetectionHandler,\n    OccupancyRepository,\n    PresenceRepository,\n\n};\n\n// General\nconst util = {};\n\nconst utils = {\n    adapters,\n    domain,\n    ports,\n    util\n};\n\nvar loaded = false;\nvar gc = global.keys();\n\n// Check if utils object is loaded\nfor (let i = 0; i < gc.length; i++) {\n\n    if (gc[i] === UTILS.OBJECT) loaded = true;\n\n}\n\nglobal.set(`${SOURCE.REPOSITORY}${UTILS.OBJECT}`, utils);\n\n// Return loaded status\nif (loaded) return status(`Utility Functions Loaded [${UTILS.OBJECT}]`);\n\n// Return non-loaded status\nreturn status(`Utility Functions Not loaded [${UTILS.OBJECT}]`);","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":700,"y":500,"wires":[[]]},{"id":"aba74432494ec151","type":"batch","z":"f9586397.5973","name":"","mode":"concat","count":10,"overlap":0,"interval":10,"allowEmptySequence":false,"topics":[{"topic":"domain"},{"topic":"ports"},{"topic":"adapters"}],"x":390,"y":420,"wires":[[]]},{"id":"52b194acf61aa6ea","type":"function","z":"f9586397.5973","name":"domain","func":"// Domain Logic\n// General Use-Case Domain Logic\n// ******************************************************************\n// -*- INPUTS -*-\n//\n// -*- OUTPUTS -*-\n// msg.payload.domain       : Domain object repository\n// ******************************************************************\n\n/*** START ***/\n\nclass Entity {\n    constructor(entityObject) {\n        this._aliases = entityObject.aliases || [];\n        this._areaId = entityObject.area_id || null;\n        this._capabilities = entityObject.capabilities || null;\n        this._configEntryId = entityObject.config_entry_id || null;\n        this._deviceClass = entityObject.device_class || null;\n        this._deviceId = entityObject.device_id || null;\n        this._disabledBy = entityObject.disabled_by || null;\n        this._entityCategory = entityObject.entity_category || null;\n        this._entityId = entityObject.entity_id || null;\n        this._hiddenBy = entityObject.hidden_by || null;\n        this._icon = entityObject.icon || null;\n        this._id = entityObject.id || null;\n        this._hasEntityName = entityObject.has_entity_name || null;\n        this._name = entityObject.name || null;\n        this._options = entityObject.options || null;\n        this._originalDeviceClass = entityObject.original_device_class || null;\n        this._originalIcon = entityObject.original_icon || null;\n        this._originalName = entityObject.original_name || null;\n        this._platform = entityObject.platform || null;\n        this._supportedFeatures = entityObject.supported_features || null;\n        this._translationKey = entityObject.translation_key || null;\n        this._uniqueId = entityObject.unique_id || null;\n        this._unitOfMeasurement = entityObject.unit_of_measurement || null;\n    }\n\n    get aliases() {\n        return this._aliases;\n    }\n\n    get areaId() {\n        return this._areaId;\n    }\n\n    get capabilities() {\n        return this._capabilities;\n    }\n\n    get configEntryId() {\n        return this._configEntryId;\n    }\n\n    get deviceClass() {\n        return this._deviceClass;\n    }\n\n    get deviceId() {\n        return this._deviceId;\n    }\n\n    get disabledBy() {\n        return this._disabledBy;\n    }\n\n    get entityCategory() {\n        return this._entityCategory;\n    }\n\n    get entityId() {\n        return this._entityId;\n    }\n\n    get hiddenBy() {\n        return this._hiddenBy;\n    }\n\n    get icon() {\n        return this._icon;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get hasEntityName() {\n        return this._hasEntityName;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get options() {\n        return this._options;\n    }\n\n    get originalDeviceClass() {\n        return this._originalDeviceClass;\n    }\n\n    get originalIcon() {\n        return this._originalIcon;\n    }\n\n    get originalName() {\n        return this._originalName;\n    }\n\n    get platform() {\n        return this._platform;\n    }\n\n    get supportedFeatures() {\n        return this._supportedFeatures;\n    }\n\n    get translationKey() {\n        return this._translationKey;\n    }\n\n    get uniqueId() {\n        return this._uniqueId;\n    }\n\n    get unitOfMeasurement() {\n        return this._unitOfMeasurement;\n    }\n}\n\nclass Area {\n    constructor(areaObject) {\n        this._aliases = areaObject.aliases || [];\n        this._name = areaObject.name || null;\n        this._id = areaObject.id || null;\n        this._picture = areaObject.picture || null;\n    }\n\n    get aliases() {\n        return this._aliases;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get picture() {\n        return this._picture;\n    }\n}\n\nclass Device {\n    constructor(deviceObject) {\n        this._area_id = deviceObject.area_id || null;\n        this._config_entries = deviceObject.config_entries || [];\n        this._configuration_url = deviceObject.configuration_url || null;\n        this._connections = deviceObject.connections || [];\n        this._disabled_by = deviceObject.disabled_by || null;\n        this._entry_type = deviceObject.entry_type || null;\n        this._hw_version = deviceObject.hw_version || null;\n        this._id = deviceObject.id || null;\n        this._identifiers = deviceObject.identifiers || [];\n        this._manufacturer = deviceObject.manufacturer || null;\n        this._model = deviceObject.model || null;\n        this._name_by_user = deviceObject.name_by_user || null;\n        this._name = deviceObject.name || null;\n        this._sw_version = deviceObject.sw_version || null;\n        this._via_device_id = deviceObject.via_device_id || null;\n    }\n\n    get area_id() {\n        return this._area_id;\n    }\n\n    get config_entries() {\n        return this._config_entries;\n    }\n\n    get configuration_url() {\n        return this._configuration_url;\n    }\n\n    get connections() {\n        return this._connections;\n    }\n\n    get disabled_by() {\n        return this._disabled_by;\n    }\n\n    get entry_type() {\n        return this._entry_type;\n    }\n\n    get hw_version() {\n        return this._hw_version;\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get identifiers() {\n        return this._identifiers;\n    }\n\n    get manufacturer() {\n        return this._manufacturer;\n    }\n\n    get model() {\n        return this._model;\n    }\n\n    get name_by_user() {\n        return this._name_by_user;\n    }\n\n    get name() {\n        return this._name;\n    }\n\n    get sw_version() {\n        return this._sw_version;\n    }\n\n    get via_device_id() {\n        return this._via_device_id;\n    }\n}\n\nconst domain = {\n\n    models: {\n        Entity,\n        Area,\n        Device\n    }\n};\n\nmsg.payload = domain;\nmsg.topic = \"domain\";\n\nreturn msg;\n/*** END ***/\n\n/*** HELPERS ***/\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":560,"y":160,"wires":[["b9408e7154a080e1"]]},{"id":"cf92dcbd555ff7b3","type":"function","z":"f9586397.5973","name":"ports","func":"// Ports\n// General Use-Case Port Logic\n// ******************************************************************\n// -*- INPUTS -*-\n//\n// -*- OUTPUTS -*-\n// msg.payload.ports        : Ports object repository\n// ******************************************************************\n\n/*** START ***/\n\nfunction motionSensorPort(motion_event) {\n    try {\n        const status = `Motion detected [${motion_event.state}] at [${motion_event.location}: ${motion_event.sensor_id}] at [${new Date(motion_event.timestamp)}]`;\n        // Core domain logic for processing motion events\n\n        return { motion_event, status };\n    } catch (error) {\n        // If an error occurs during processing, return the error message\n        return { motion_event, status: `Error processing motion event: ${error.message}` }\n    }\n}\n\nfunction climatePort(temperature, sensor_id, area) {\n    try {\n        const status = `Climate Updated: [${temperature}] at [${area}: ${sensor_id}] at [${Date.now()}]`;\n        // Core domain logic for processing temperature events\n        const temperature_event = {\n            state : temperature,\n            location: area,\n            last_updated: Date.now()\n        }\n\n        return { temperature_event, status };\n    } catch (error) {\n        // If an error occurs during processing, return the error message\n        return { temperature, sensor_id, area, status: `Error processing temperature event: ${error.message}` }\n    }\n}\n\nconst ports = {\n    motionSensorPort,\n    climatePort\n};\n\nmsg.payload = ports;\nmsg.topic = \"ports\";\nreturn msg;\n/*** END ***/\n\n/*** HELPERS ***/\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":570,"y":200,"wires":[["b9408e7154a080e1"]]},{"id":"0fad4bf7b7fb21fe","type":"function","z":"f9586397.5973","name":"adapters","func":"// Adapter Logic\n// General Use-Case Adapter Logic\n// ******************************************************************\n// -*- INPUTS -*-\n//\n// -*- OUTPUTS -*-\n// msg.payload.adapters     : adapters object repository\n// ******************************************************************\n\n/*** START ***/\n\nfunction testAdapter() {\n    node.warn(\"hello!\");\n}\n\nconst adapters = {\n    testAdapter\n};\n\nmsg.topic = \"adapters\";\nmsg.payload = adapters;\n\nreturn msg;\n/*** END ***/\n\n/*** HELPERS ***/\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":560,"y":240,"wires":[["b9408e7154a080e1"]]},{"id":"05bb98ad5bbf37ab","type":"function","z":"f9586397.5973","d":true,"name":"util","func":"// Load Environment Variables\n// Load Environment Variables + utils\n// ******************************************************************\n// -*- INPUTS -*-\n//\n// -*- OUTPUTS -*-\n// msg.payload.adapters     : adapters object repository\n// ******************************************************************\n\n// Default to system, object if no GLOBAL_ID environment variable passed\nconst SOURCE = getPathObject(env.get(\"GLOBAL_ID\") || \"system\");\n\n// Core Modules\nconst DOMAIN = getPathObject(`${SOURCE.REPOSITORY}domain`);\nconst PORTS = getPathObject(`${SOURCE.REPOSITORY}ports`);\nconst ADAPTERS = getPathObject(`${SOURCE.REPOSITORY}adapters`);\nconst UTIL = getPathObject(`${SOURCE.REPOSITORY}util`);\n\n// Core Data\nconst ENTITIES = getPathObject(`${SOURCE.REPOSITORY}entities`);\nconst AREAS = getPathObject(`${SOURCE.REPOSITORY}areas`);\nconst DEVICES = getPathObject(`${SOURCE.REPOSITORY}devices`);\n\n// Use Cases\nconst OCCUPANCY = getPathObject(`${SOURCE.REPOSITORY}occupancy`);\nconst PRESENCE = getPathObject(`${SOURCE.REPOSITORY}presence`);\n\nconst WaitTimerManager = global.get(`${DOMAIN.OBJECT}.models.WaitTimerManager`);\n\nconst path = {\n    SOURCE,\n    DOMAIN,\n    PORTS,\n    ADAPTERS,\n    UTIL,\n    ENTITIES,\n    AREAS,\n    DEVICES,\n    OCCUPANCY,\n    PRESENCE\n};\n\n// For global context path setup\nfunction getPathObject(path) {\n\n    return {\n        REPOSITORY: append(path, \".\"),\n        OBJECT: abate(path, \".\")\n    };\n}\n\n// Rounding function with precision\nfunction round(value, precision) {\n\n    // Return raw value if no precision passed\n    if (!exists(precision)) return value;\n\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(value * multiplier) / multiplier;\n}\n\n// Check if entity_id was passed, and remove domain\nfunction getGlobalID(globalID) {\n\n    // If an entity_id was passed, remove domain\n    if (exists(globalID) && globalID.includes(\".\")) {\n\n        globalID = globalID.split(\".\")[1];\n\n    }\n\n    // Return global ID\n    return globalID;\n}\n\n// Check if a value exists\nfunction exists(value) {\n\n    var valueType = typeof value;\n\n    // Check for empty string\n    if (valueType === \"string\") {\n        if (value == \"\" || (value.length == 0)) return false;\n    }\n\n    // null check\n    if (value === null) return false;\n\n    // undefined check\n    if (valueType === \"undefined\") return false;\n\n    // Empty object check\n    if (valueType == \"object\") {\n        if (Object.keys(value).length === 0) return false;\n    }\n\n    //return value != (\"\" || undefined || null || (value.length == 0));\n    return true;\n\n}\n\n// Create a new object and assign message to payload\nfunction status(message, properties = { fill: \"green\", shape: \"dot\" }) {\n    return {\n        \"payload\": {\n            ...properties,\n            text: message\n        }\n    };\n}\n\n// Sets an object attribute to a given value\nfunction setAttribute(property, attribute, value) {\n\n    // Check if msg property is an object\n    if (!(typeof property === 'object')) {\n        property = {};\n    }\n\n    // If attribute not passed, default to payload\n    if (!exists(attribute)) {\n        attribute = \"payload\";\n    }\n\n    // Set value\n    property[attribute] = value;\n\n    return property;\n\n}\n\n// Append character to end of string if not present\nfunction append(value, character) {\n\n    // Check if end of string matches character\n    if (value.charAt(value.length - character.length) !== character) {\n\n        // Append character if not found\n        value = value + character;\n    }\n\n    return value;\n\n}\n\n// Remove character from end of string\nfunction abate(value, character) {\n\n    // Check if end of string matches character(s) \n    if (value.charAt(value.length - character.length) === character) {\n\n        // Abate character if found\n        value = value.substring(0, value.length - character.length);\n    }\n\n    return value;\n\n}\n\nfunction getFileNameFromPath(filePath) {\n    const parts = filePath.split('/');\n    return parts[parts.length - 1];\n}\n\nfunction mapArrayToDict(entities, key) {\n    const entityDict = {};\n\n    entities.forEach(entity => {\n        entityDict[entity[key]] = entity;\n    });\n\n    return entityDict;\n}\n\nfunction currentState(entityId) {\n    return global.get(\"homeassistant.homeAssistant.states\")[entityId];\n}\n\n// Cast Object to array\nfunction castToArray(value) {\n    return (Array.isArray(value)) ? value : [value];\n}\n\n// Function to get attribute values from event data\nfunction getEventAttributes(event, attributes) {\n    return attributes.map(attr => event[attr]);\n}\n\n// Function to get an entity from an entities object\nfunction getEntity(entity_id) {\n\n    return new Promise((resolve, reject) => {\n\n        // Timeout value in milliseconds\n        const TIMEOUT = 10000;\n\n        const entities = global.get(ENTITIES.OBJECT);\n        //const entities = EntitiesRepository.getObject();\n\n        // Check if entities are already available\n        if (exists(entities)) {\n            resolve(entities[entity_id]);\n        } else {\n            const WaitTimerManager = global.get(`${DOMAIN.REPOSITORY}`).models.WaitTimerManager;\n            const waitManager = new WaitTimerManager();\n\n            // Function to handle timer callback\n            const timerCallback = function (error) {\n                if (error) {\n                    // Timeout occurred\n                    reject(new Error(`Entities not loaded within ${TIMEOUT} ms`));\n                } else {\n                    // Re-fetch the entities object and resolve the promise\n                    const loaded_entities = global.get(ENTITIES.OBJECT);\n                    //const loaded_entities = EntitiesRepository.getObject();\n                    if (loaded_entities) {\n                        // Fetch the entity from the entities object\n                        resolve(loaded_entities[entity_id]);\n                        // Cancel the wait timer\n                        waitManager.clearWaitTimer(ENTITIES.OBJECT);\n                    }\n                    // Entities object not available yet, retrying...\n                }\n            };\n\n            // Create wait timer\n            waitManager.createWaitTimer(ENTITIES.OBJECT, timerCallback, TIMEOUT);\n            node.warn(\"Waiting for entities...\");\n        }\n    });\n}\n\n// Function to get an object from global context\nfunction waitForGlobalContext(global_id, TIMEOUT = 10000) {\n    return new Promise((resolve, reject) => {\n\n        const object_value = global.get(global_id);\n\n        // Check if value is already available\n        if (exists(object_value)) {\n            resolve(object_value);\n        } else {\n\n            const waitManager = new WaitTimerManager();\n\n            // Function to handle timer callback\n            const timerCallback = function (error) {\n                if (error) {\n                    // Timeout occurred\n                    reject(new Error(`Object not loaded within ${TIMEOUT} ms`));\n                } else {\n                    // Re-fetch the object and resolve the promise\n                    const loaded_object_value = global.get(global_id);\n                    node.warn(`Reloading object: ${loaded_object_value}`);\n                    if (loaded_object_value) {\n                        node.warn(`Object loaded (${global_id}): ${loaded_object_value}`);\n                        resolve(loaded_object_value);\n                        // Cancel the wait timer\n                        waitManager.clearWaitTimer(global_id);\n                    }\n                    node.warn(`Object not available yet, retrying...`);\n                }\n            };\n\n            // Create wait timer\n            waitManager.createWaitTimer(global_id, timerCallback, TIMEOUT);\n            node.warn(\"Waiting for object...\");\n        }\n    });\n}\n\nfunction getGlobalAsync(globalId, timeout = 10000) {\n    return new Promise((resolve, reject) => {\n        const interval = setInterval(() => {\n            const obj = global.get(globalId);\n            if (obj !== undefined) {\n                clearInterval(interval);\n                resolve(obj);\n            }\n        }, 1000); // Check every second\n\n        setTimeout(() => {\n            clearInterval(interval);\n            reject(new Error(`Timeout reached while waiting for global context object: ${globalId}`));\n        }, timeout);\n    });\n}\n\nconst util = {\n    path,\n    round,\n    getGlobalID,\n    exists,\n    status,\n    setAttribute,\n    append,\n    abate,\n    getFileNameFromPath,\n    mapArrayToDict,\n    currentState,\n    castToArray,\n    getEventAttributes,\n    getEntity,\n    waitForGlobalContext,\n    getGlobalAsync\n\n};\nmsg.topic = \"util\";\nmsg.payload = util;\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":270,"y":200,"wires":[["cf92dcbd555ff7b3","52b194acf61aa6ea","0fad4bf7b7fb21fe","b9408e7154a080e1"]]},{"id":"b9408e7154a080e1","type":"join","z":"f9586397.5973","name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"4","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":770,"y":200,"wires":[["cdba6a1bd9ad79e5"]]},{"id":"cdba6a1bd9ad79e5","type":"function","z":"f9586397.5973","name":"Load Modules","func":"/** Load Modules **/\n\nconst SOURCE = msg.payload.util.path.SOURCE;\n\n// Store repository object to global context \nglobal.set(`${SOURCE.OBJECT}`, msg.payload);\n\nconst gc = global.keys();\nconst loaded = gc.includes(SOURCE.OBJECT);\nconst status = msg.payload.util.status;\n\n// Return loaded status\nif (loaded) return status(`Modules Loaded [${SOURCE.OBJECT}]`);\n\n// Return non-loaded status\nreturn status(`Modules Not loaded [${SOURCE.OBJECT}]`);","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":940,"y":200,"wires":[[]]},{"id":"b757f49d58e470e6","type":"function","z":"f9586397.5973","d":true,"name":"Utility Functions","func":"/** Utility Functions **/\n\n// Default to utils object if no UTIL_GC environment variable passed\nconst UTILS = getPathObject(env.get(\"UTIL_GC\") || \"utils\");\nconst object_id = UTILS.REPOSITORY;\n\nconst SOURCE = getPathObject(env.get(\"GLOBAL_ID\") || \"system\");\n\nconst ENTITIES = getPathObject(`${SOURCE.REPOSITORY}entities`);\nconst AREAS = getPathObject(`${SOURCE.REPOSITORY}areas`);\nconst DEVICES = getPathObject(`${SOURCE.REPOSITORY}devices`);\nconst OCCUPANCY = getPathObject(`${SOURCE.REPOSITORY}occupancy`);\nconst PRESENCE = getPathObject(`${SOURCE.REPOSITORY}presence`);\n\n// For testing / debugging purposes\nfunction healthCheck () {\n    return true;\n}\n\n// For global context path setup\nfunction getPathObject(path) {\n\n    return {\n        REPOSITORY: append(path, \".\"),\n        OBJECT: abate(path, \".\")\n    };\n}\n\n// Rounding function with precision\nfunction round(value, precision) {\n\n    // Return raw value if no precision passed\n    if (!exists(precision)) return value;\n\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(value * multiplier) / multiplier;\n}\n\n// Check if entity_id was passed, and remove domain\nfunction getGlobalID(globalID) {\n\n    // If an entity_id was passed, remove domain\n    if (exists(globalID) && globalID.includes(\".\")) {\n\n        globalID = globalID.split(\".\")[1];\n\n    }\n\n    // Return global ID\n    return globalID;\n}\n\n// Check if a value exists\nfunction exists(value) {\n\n    var valueType = typeof value;\n\n    // Check for empty string\n    if (valueType === \"string\") {\n        if (value == \"\" || (value.length == 0)) return false;\n    }\n\n    // null check\n    if (value === null) return false;\n\n    // undefined check\n    if (valueType === \"undefined\") return false;\n\n    // Empty object check\n    if (valueType == \"object\") {\n        if (Object.keys(value).length === 0) return false;\n    }\n\n    //return value != (\"\" || undefined || null || (value.length == 0));\n    return true;\n\n}\n\n// Create a new object and assign message to payload\nfunction status(message, properties = { fill: \"green\", shape: \"dot\" }) {\n    return {\n        \"payload\": {\n            ...properties,\n            text: message\n        }\n    };\n}\n\n// Create a new object and assign message to payload (finish for me pls <3)\nfunction statusOld(message) {\n    return { \"payload\": message };\n}\n\n// Sets an object attribute to a given value\nfunction setAttribute (property, attribute, value) {\n    \n    // Check if msg property is an object\n    if (!(typeof property === 'object')) {\n        property = {};\n    }\n    \n    // If attribute not passed, default to payload\n    if (!exists(attribute)) {\n        attribute = \"payload\";\n    }\n\n    // Set value\n    property[attribute] = value;\n\n    return property;\n\n}\n\n// Append character to end of string if not present\nfunction append(value, character) {\n\n    // Check if end of string matches character\n    if (value.charAt(value.length - character.length) !== character) {\n\n        // Append character if not found\n        value = value + character;\n    }\n\n    return value;\n\n}\n\n// Remove character from end of string\nfunction abate(value, character) {\n\n    // Check if end of string matches character(s) \n    if (value.charAt(value.length - character.length) === character) {\n\n        // Abate character if found\n        value = value.substring(0, value.length - character.length);\n    }\n\n    return value;\n\n}\n\n// Cast Object to array\nfunction castToArray(value) {\n    return (Array.isArray(value)) ? value : [value];\n}\n\n// Function to get attribute values from event data\nfunction getEventAttributes(event, attributes) {\n    return attributes.map(attr => event[attr]);\n}\n\n// Function to get an entity from an entities object\nfunction getEntity(entity_id) {\n    return new Promise((resolve, reject) => {\n\n        // Timeout value in milliseconds\n        const TIMEOUT = 10000; \n\n        const entities = global.get(ENTITIES.OBJECT);\n        //const entities = EntitiesRepository.getObject();\n\n        // Check if entities are already available\n        if (exists(entities)) {\n            resolve(entities[entity_id]);\n        } else {\n            const waitManager = new WaitTimerManager();\n\n            // Function to handle timer callback\n            const timerCallback = function (error) {\n                if (error) {\n                    // Timeout occurred\n                    reject(new Error(`Entities not loaded within ${TIMEOUT} ms`));\n                } else {\n                    // Re-fetch the entities object and resolve the promise\n                    const loaded_entities = global.get(ENTITIES.OBJECT);\n                    //const loaded_entities = EntitiesRepository.getObject();\n                    if (loaded_entities) {\n                        // Fetch the entity from the entities object\n                        resolve(loaded_entities[entity_id]);\n                        // Cancel the wait timer\n                        waitManager.clearWaitTimer(ENTITIES.OBJECT); \n                    }\n                    // Entities object not available yet, retrying...\n                }\n            };\n\n            // Create wait timer\n            waitManager.createWaitTimer(ENTITIES.OBJECT, timerCallback, TIMEOUT);\n            node.warn(\"Waiting for entities...\");\n        }\n    });\n}\n\n// Function to get an object from global context\nfunction waitForGlobalContext(global_id, TIMEOUT = 10000) {\n    return new Promise((resolve, reject) => {\n\n        const object_value = global.get(global_id);\n\n        // Check if value is already available\n        if (exists(object_value)) {\n            resolve(object_value);\n        } else {\n            const waitManager = new WaitTimerManager();\n\n            // Function to handle timer callback\n            const timerCallback = function (error) {\n                if (error) {\n                    // Timeout occurred\n                    reject(new Error(`Object not loaded within ${TIMEOUT} ms`));\n                } else {\n                    // Re-fetch the object and resolve the promise\n                    const loaded_object_value = global.get(global_id);\n                    node.warn(`Reloading object: ${loaded_object_value}`);\n                    if (loaded_object_value) {\n                        node.warn(`Object loaded (${global_id}): ${loaded_object_value}`);\n                        resolve(loaded_object_value);\n                        // Cancel the wait timer\n                        waitManager.clearWaitTimer(global_id);\n                    }\n                    node.warn(`Object not available yet, retrying...`);\n                }\n            };\n\n            // Create wait timer\n            waitManager.createWaitTimer(global_id, timerCallback, TIMEOUT);\n            node.warn(\"Waiting for object...\");\n        }\n    });\n}\n\nfunction getGlobalAsync(globalId, timeout = 10000) {\n    return new Promise((resolve, reject) => {\n        const interval = setInterval(() => {\n            const obj = global.get(globalId);\n            if (obj !== undefined) {\n                clearInterval(interval);\n                resolve(obj);\n            }\n        }, 1000); // Check every second\n\n        setTimeout(() => {\n            clearInterval(interval);\n            reject(new Error(`Timeout reached while waiting for global context object: ${globalId}`));\n        }, timeout);\n    });\n}\n\n\n//**API **//\n\nfunction createResponseObject(response_code, message) {\n    return {\n        \"response_code\": response_code,\n        \"data\": message\n    }\n}\n\nfunction generateToggleSwitchValueTemplate(toggleEntityId, triggerEntityId, triggerEntityState) {\n    return `{% if is_state('${toggleEntityId}', 'on') %}\n        {{ is_state('${triggerEntityId}', '${triggerEntityState}') }}\n        {% else %}\n        {{ is_state('${toggleEntityId}', 'on') }}\n        {% endif %}`;\n}\n\nfunction generateTemplateSwitchObject(switchId, friendlyName, valueTemplate, turnOnAction, turnOffAction, iconTemplate) {\n    const switchObject = {\n        [switchId]: {\n            friendly_name: friendlyName,\n            value_template: valueTemplate,\n            turn_on: [turnOnAction],\n            turn_off: [turnOffAction],\n            icon_template: iconTemplate\n        }\n    };\n    return switchObject;\n}\n\nfunction generateYamlTemplateObject(entity_type) {\n    const yamlObject = {\n        platform: 'template',\n        [entity_type]: {}\n    };\n    return [yamlObject];\n}\n\nfunction addEntityToTemplateObject(yamlObject, entity_type, entity) {\n    yamlObject[0][entity_type] = {\n        ...yamlObject[0][entity_type],\n        ...entity\n    };\n    return yamlObject;\n}\n\nfunction createTurnOnOffObject(service, data = {}) {\n    return {\n        turn_on: [\n            {\n                service: service,\n                ...data.turn_on // Spread additional turn_on data if provided\n            }\n        ],\n        turn_off: [\n            {\n                service: service,\n                ...data.turn_off // Spread additional turn_off data if provided\n            }\n        ]\n    };\n}\n\nfunction createIconTemplate(onStateIcon, offStateIcon = null, triggerEntityId = null, triggerEntityState = null) {\n    if (!offStateIcon) {\n        return `mdi:${onStateIcon}`;\n    } else {\n        return `{% if is_state('${triggerEntityId}', '${triggerEntityState}') %}\n            mdi:${onStateIcon}\n        {% else %}\n            mdi:${offStateIcon}\n        {% endif %}`;\n    }\n}\n\nfunction getFileNameFromPath(filePath) {\n    const parts = filePath.split('/');\n    return parts[parts.length - 1];\n}\n\nfunction mapArrayToDict(entities, key) {\n    const entityDict = {};\n\n    entities.forEach(entity => {\n        entityDict[entity[key]] = entity;\n    });\n\n    return entityDict;\n}\n\nfunction currentState(entityId) {\n    return global.get(\"homeassistant.homeAssistant.states\")[entityId];\n}\n\nclass Remote {\n    constructor(remoteId, buttons = {}) {\n        this.remoteId = remoteId;\n        this.buttons = {};\n\n        // Check if buttons is an instance of Remote, if not, convert each entry to a Button instance\n        if (!(buttons instanceof Remote)) {\n            for (const buttonId in buttons) {\n                if (buttons.hasOwnProperty(buttonId)) {\n                    this.addButton(buttonId, buttons[buttonId]);\n                }\n            }\n        }\n    }\n\n    addButton(buttonId, sourceButton = null) {\n        const button = sourceButton instanceof Button ? sourceButton : new Button(buttonId, sourceButton);\n        this.buttons[buttonId] = button;\n        return button;\n    }\n\n    getId() {\n        return this.remoteId;\n    }\n\n    getObject() {\n        const remoteObject = {};\n        Object.keys(this.buttons).forEach(buttonId => {\n            remoteObject[buttonId] = this.buttons[buttonId].getObject();\n        });\n        return remoteObject;\n    }\n}\n\nclass Button {\n    constructor(buttonId, commands = {}) {\n        this.buttonId = buttonId;\n        this.commands = {};\n\n        // Check if commands is an instance of Button, if not, convert each entry to a Command instance\n        if (!(commands instanceof Button)) {\n            for (const commandId in commands) {\n                if (commands.hasOwnProperty(commandId)) {\n                    this.addCommand(commandId, commands[commandId]);\n                }\n            }\n        }\n    }\n\n    addCommand(commandId, sourceCommand = null) {\n        const command = sourceCommand instanceof Command ? sourceCommand : new Command(commandId, sourceCommand);\n        this.commands[commandId] = command;\n        return command;\n    }\n\n    getId() {\n        return this.buttonId;\n    }\n\n    getObject() {\n        const buttonObject = {};\n        Object.keys(this.commands).forEach(commandId => {\n            buttonObject[commandId] = this.commands[commandId].getObject();\n        });\n        return buttonObject;\n    }\n}\n\nclass Command {\n    constructor(commandId, action = {}) {\n        this.commandId = commandId;\n        this.action = action;\n    }\n\n    getId() {\n        return this.commandId;\n    }\n\n    getObject() {\n        return this.action;\n    }\n}\n\n\nclass RemoteInterface {\n    constructor(remoteConfig = {}) {\n        this.remotes = {};\n        if (remoteConfig instanceof Remote) {\n            this.setRemote(remoteConfig.getId(), remoteConfig);\n        } else {\n            const remotes = remoteConfig.remotes || {};\n            Object.keys(remotes).forEach(remoteId => {\n                this.setRemote(remoteId, remotes[remoteId]);\n            });\n        }\n    }\n\n\n    setRemote(remoteId, sourceRemote = null) {\n        if (sourceRemote instanceof Remote) {\n            this.remotes[remoteId] = sourceRemote;\n        } else if (sourceRemote) {\n\n            if (!validateRemote(sourceRemote)) {\n                throw new Error('Invalid remote configuration');\n            }\n            this.remotes[remoteId] = new Remote(remoteId, sourceRemote);\n        } else {\n            this.remotes[remoteId] = new Remote(remoteId);\n        }\n        return this.remotes[remoteId];\n    }\n\n    setButton(remoteId, buttonId, sourceButton = null) {\n        if (!this.remotes[remoteId]) {\n            this.setRemote(remoteId); // Ensure remote exists before setting button\n        }\n        const button = this.remotes[remoteId].addButton(buttonId, sourceButton);\n        return button;\n    }\n\n\n    setCommand(remoteId, buttonId, commandId, sourceCommand = null) {\n        if (!this.remotes[remoteId]) {\n            this.setRemote(remoteId);\n        }\n        if (!this.remotes[remoteId].buttons[buttonId]) {\n            this.setButton(remoteId, buttonId);\n        }\n        const button = this.remotes[remoteId].buttons[buttonId];\n        const command = button.addCommand(commandId, sourceCommand);\n        return command;\n    }\n\n    getCommand(remoteId, buttonId, commandId) {\n        const remote = this.remotes[remoteId];\n\n        if (!remote) {\n            throw new Error(`Remote not found for ID ${remoteId}`);\n        }\n\n        const button = remote.buttons[buttonId];\n        if (!button) {\n            throw new Error(`Button not found for ID ${buttonId}`);\n        }\n\n        const command = button.commands[commandId];\n        if (!command) {\n            throw new Error(`Command not found for ID ${commandId}`);\n        }\n\n        return command;\n    }\n\n    getRemoteIds() {\n        return Object.keys(this.remotes);\n    }\n\n    // Ignore this, it's for debugging\n    getButtonIds2(remoteId) {\n        if (this.remotes[remoteId]) {\n            return Object.keys(this.remotes[remoteId].buttons);\n        }\n        return [];\n    }\n\n    getButtonIds(remoteId) {\n        if (this.remotes[remoteId]) {\n            if (this.remotes[remoteId] instanceof Button) {\n                // If the value is an instance of Button, return its ID\n                return [this.remotes[remoteId].getId()];\n            } else {\n                // Otherwise, assume it's an object with button IDs as keys\n                return Object.keys(this.remotes[remoteId]);\n            }\n        }\n        return [];\n    }\n\n    getCommandIds(remoteId, buttonId) {\n        if (this.remotes[remoteId] && this.remotes[remoteId].buttons[buttonId]) {\n            return Object.keys(this.remotes[remoteId].buttons[buttonId].commands);\n        }\n        return [];\n    }\n\n    getObject() {\n        return {\n            remotes: this.remotes\n        };\n    }\n}\n\n// Validation functions\nfunction validateRemote(remoteConfig) {\n    if (remoteConfig instanceof Remote) {\n        // If remoteConfig is already an instance of Remote, it's valid\n        return true;\n    } else if (typeof remoteConfig === 'object' && remoteConfig !== null) {\n        const remoteInstance = new Remote('remoteId');\n\n        // Iterate over each button in the remote\n        Object.keys(remoteConfig).forEach(buttonId => {\n            const commandConfigs = remoteConfig[buttonId];\n            const buttonInstance = new Button(buttonId);\n\n            // Iterate over each command in the button\n            Object.keys(commandConfigs).forEach(commandId => {\n                const commandInstance = new Command(commandId, commandConfigs[commandId]);\n\n                // Add the command to the button\n                buttonInstance.addCommand(commandId, commandInstance);\n            });\n\n            // Add the button to the remote\n            remoteInstance.addButton(buttonId, buttonInstance);\n        });\n\n        // Validate the remote instance\n        const isValid = validateRemote(remoteInstance);\n        return isValid;\n    } else {\n        return false; // Invalid remote configuration\n    }\n}\n\n\n\nfunction validateButton(buttonConfig) {\n    if (buttonConfig instanceof Button) {\n        // If buttonConfig is an instance of Button class, we'll validate its commands\n        for (const commandId in buttonConfig.commands) {\n            if (!buttonConfig.commands.hasOwnProperty(commandId)) {\n                continue;\n            }\n            const command = buttonConfig.commands[commandId];\n            if (!(command instanceof Command)) {\n                return false; // Invalid command within the button\n            }\n            // Optionally, add specific validation logic for command configuration here\n        }\n        return true; // All checks passed\n    } else if (typeof buttonConfig === 'object' && buttonConfig !== null && buttonConfig.hasOwnProperty('commands')) {\n        // If buttonConfig is an object representation, we'll recursively call validateCommand for each command\n        for (const commandId in buttonConfig.commands) {\n            if (!buttonConfig.commands.hasOwnProperty(commandId)) {\n                continue;\n            }\n            if (!validateCommand(buttonConfig.commands[commandId])) {\n                return false; // Invalid command configuration\n            }\n        }\n        return true; // All checks passed\n    } else {\n        return false; // Invalid button configuration\n    }\n}\n\nfunction validateCommand(commandConfig) {\n    if (commandConfig instanceof Command) {\n        // If commandConfig is an instance of Command class, it's valid\n        return true;\n    } else if (typeof commandConfig === 'object' && commandConfig !== null) {\n        // If commandConfig is an object representation, we'll check its properties\n        if (commandConfig.hasOwnProperty('commandId') && commandConfig.hasOwnProperty('action')) {\n            // Optionally, add specific validation logic for command configuration here\n            return true; // All checks passed\n        }\n    }\n    return false; // Invalid command configuration\n}\n\nclass DeviceManager {\n    constructor(mapping = {}) {\n        this.devices = mapping;\n    }\n\n    setDevice(device_id, data) {\n        this.devices[device_id] = data;\n    }\n\n    getDevice(device_id) {\n        return this.devices[device_id];\n    }\n\n    removeDevice(device_id) {\n        if (this.devices.hasOwnProperty(device_id)) {\n            delete this.devices[device_id];\n        }\n    }\n\n    getDevices() {\n        return this.devices;\n    }\n}\n\nclass DebounceTimerManager {\n    constructor() {\n        this.timers = {};\n    }\n\n    createTimer(attributeValues, debounceTimers, callback, delay) {\n        let nestedObject = debounceTimers;\n        for (const attrValue of attributeValues) {\n            nestedObject[attrValue] = nestedObject[attrValue] || {};\n            nestedObject = nestedObject[attrValue];\n        }\n        if (!nestedObject.hasOwnProperty('timer')) {\n            nestedObject.timer = setTimeout(callback, delay);\n        }\n    }\n\n    updateTimer(attributeValues, debounceTimers, callback, delay) {\n        this.clearTimer(attributeValues, debounceTimers);\n        this.createTimer(attributeValues, debounceTimers, callback, delay);\n    }\n\n    clearTimer(attributeValues, debounceTimers) {\n        let nestedObject = debounceTimers;\n        for (const attrValue of attributeValues) {\n            if (!nestedObject[attrValue]) {\n                return;\n            }\n            nestedObject = nestedObject[attrValue];\n        }\n        if (nestedObject.timer) {\n            clearTimeout(nestedObject.timer);\n            delete nestedObject.timer;\n        }\n    }\n}\n\nclass WaitTimerManager {\n    constructor() {\n        this.timers = {};\n        this.callbacks = {}; // Store callbacks for each event or condition\n        this.checkInterval = 1000; // Interval in milliseconds for checking existence\n    }\n\n    // Create a timer that waits for the item to exist\n    createWaitTimer(item, callback, timeout = null) {\n        // Check if the item already has callbacks registered\n        if (!this.callbacks[item]) {\n            this.callbacks[item] = [];\n        }\n\n        // Add the new callback to the list of callbacks for this item\n        this.callbacks[item].push(callback);\n\n        // If the timer doesn't exist, create it\n        if (!this.timers[item]) {\n            if (timeout !== null) {\n                // If timeout is provided, clear the timer after the specified duration\n                this.timers[item] = setTimeout(() => {\n                    this.clearWaitTimer(item);\n                    this.invokeCallbacks(item, new Error(`Timeout waiting for ${item}`));\n                }, timeout);\n            }\n\n            // Check for the existence of the item periodically\n            this.checkExistence(item);\n        }\n    }\n\n    // Check for the existence of the item periodically\n    checkExistence(item) {\n        const interval = setInterval(() => {\n            if (global.get(item) !== undefined) {\n                clearInterval(interval);\n                this.invokeCallbacks(item, null); // Item found\n            }\n        }, this.checkInterval);\n    }\n\n    // Invoke all callbacks associated with the item\n    invokeCallbacks(item, error) {\n        if (this.callbacks[item]) {\n            this.callbacks[item].forEach(callback => {\n                callback(error);\n            });\n            delete this.callbacks[item]; // Remove the callbacks for this item\n        }\n    }\n\n    // Clear the timer associated with the item\n    clearWaitTimer(item) {\n        if (this.timers[item]) {\n            clearTimeout(this.timers[item]);\n            delete this.timers[item];\n        }\n    }\n}\n\n// Create a singleton instance of WaitTimerManager\nconst waitTimerManager = new WaitTimerManager();\n\nclass Person {\n    constructor(person_object) {\n        // Assign properties from the personObj parameter\n        this.entityId = person_object.entity_id;\n        this.oldState = person_object.old_state;\n        this.newState = person_object.new_state;\n    }\n\n    isPresent() {\n        return this.newState.state !== 'not_home';\n    }\n\n    getId() {\n        return this.newState.attributes.id;\n    }\n\n    // Other methods for manipulating the person object can be added here\n}\n\nclass MotionEvent {\n    constructor(sensor_id, location, timestamp, state = \"on\", attr = {}) {\n        this.sensor_id = sensor_id;\n        this.location = location;\n        this.timestamp = timestamp;\n        // Check if state is passed as an attribute\n        if (typeof state === \"object\") {\n            attr = state; // Treat state as part of the attributes\n            state = \"on\"; // Default state if not provided separately\n        }\n        this.state = state;\n        // Spread optional attributes onto the class instance\n        Object.assign(this, attr);\n    }\n}\n\n// Motion detection handler function\nfunction motionDetectionHandler(event_data) {\n\n    if (!event_data) {\n        const message = \"[ERROR]: Missing motion event data\";\n        node.warn(message);\n        node.status(status(message, { fill: \"red\" }).payload);\n        return null;\n    }\n\n    const sensor_id = event_data.entity_id;\n\n    return getEntity(sensor_id)\n        .then(entity => {\n            // If an entity_id was found, get location/area_id\n            const location = entity.area_id;\n\n            // Create MotionEvent object\n            const motion_event_obj = new MotionEvent(\n                sensor_id, // entity\n                location, // area_id\n                event_data.last_changed, // timestamp\n                //{ last_updated: event_data.last_updated }\n                event_data\n            );\n            // Call the registered callback function on the motion sensor port with the event data\n            return motionSensorPort(motion_event_obj);\n        })\n        .catch(error => {\n            // Handle any errors thrown by getEntity\n            const message = `[ERROR]: ${error.message}`;\n            node.warn(message);\n            node.status(status(message, { fill: \"red\" }).payload);\n            return null;\n        });\n\n}\n\n// Occupancy Repository\nclass OccupancyRepository {\n    static getObject() {\n        return global.get(OCCUPANCY.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(OCCUPANCY.OBJECT, value);\n    }\n}\n\n// Presence Repository\nclass PresenceRepository {\n    static getObject() {\n        return global.get(PRESENCE.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(PRESENCE.OBJECT, value);\n    }\n}\n\n// Source Repository\nclass SourceRepository {\n    static getObject() {\n        return global.get(SOURCE.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(SOURCE.OBJECT, value);\n    }\n}\n\n// Entities Repository\nclass EntitiesRepository {\n    static getObject() {\n        return global.get(ENTITIES.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(ENTITIES.OBJECT, value);\n    }\n}\n\n// Areas Repository\nclass AreasRepository {\n    static getObject() {\n        return global.get(AREAS.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(AREAS.OBJECT, value);\n    }\n}\n\n// Devices Repository\nclass DevicesRepository {\n    static getObject() {\n        return global.get(DEVICES.OBJECT);\n    }\n\n    static setObject(value) {\n        global.set(DEVICES.OBJECT, value);\n    }\n}\n\nfunction motionSensorPort(motion_event) {\n    try {\n        const status = `Motion detected [${motion_event.state}] at [${motion_event.location}: ${motion_event.sensor_id}] at [${new Date(motion_event.timestamp)}]`;\n        // Core domain logic for processing motion events\n\n        return {motion_event, status};\n    } catch (error) {\n        // If an error occurs during processing, return the error message\n        return {motion_event, status:`Error processing motion event: ${error.message}`}\n    }\n}\n\n// General\nglobal.set(`${object_id}healthCheck`, healthCheck);\nglobal.set(`${object_id}round`, round);\nglobal.set(`${object_id}getGlobalID`, getGlobalID);\nglobal.set(`${object_id}exists`, exists);\nglobal.set(`${object_id}status`, status);\nglobal.set(`${object_id}setAttribute`, setAttribute);\nglobal.set(`${object_id}append`, append);\nglobal.set(`${object_id}abate`, abate);\nglobal.set(`${object_id}getFileNameFromPath`, getFileNameFromPath);\nglobal.set(`${object_id}mapArrayToDict`, mapArrayToDict);\nglobal.set(`${object_id}currentState`, currentState);\nglobal.set(`${object_id}castToArray`, castToArray);\nglobal.set(`${object_id}getEventAttributes`, getEventAttributes);\nglobal.set(`${object_id}getEntity`, getEntity);\nglobal.set(`${object_id}waitForGlobalContext`, waitForGlobalContext);\nglobal.set(`${object_id}getGlobalAsync`, getGlobalAsync);\n\n// API\nglobal.set(`${object_id}createResponseObject`, createResponseObject);\n\n// .yaml template generation\nglobal.set(`${object_id}generateToggleSwitchValueTemplate`, generateToggleSwitchValueTemplate);\nglobal.set(`${object_id}generateTemplateSwitchObject`, generateTemplateSwitchObject);\nglobal.set(`${object_id}generateYamlTemplateObject`, generateYamlTemplateObject);\nglobal.set(`${object_id}addEntityToTemplateObject`, addEntityToTemplateObject);\nglobal.set(`${object_id}createTurnOnOffObject`, createTurnOnOffObject);\nglobal.set(`${object_id}createIconTemplate`, createIconTemplate);\n\n// RemoteInterface\nglobal.set(`${object_id}RemoteInterface`, RemoteInterface);\nglobal.set(`${object_id}Remote`, Remote);\nglobal.set(`${object_id}Button`, Button);\nglobal.set(`${object_id}Command`, Command);\n\n// Device Manager\nglobal.set(`${object_id}DeviceManager`, DeviceManager);\n\n// Timer Managers\nglobal.set(`${object_id}DebounceTimerManager`, DebounceTimerManager);\nglobal.set(`${object_id}WaitTimerManager`, WaitTimerManager);\n\n// Person\nglobal.set(`${object_id}Person`, Person);\n\n// Domains\nglobal.set(`${object_id}MotionEvent`, MotionEvent);\nglobal.set(`${object_id}motionDetectionHandler`, motionDetectionHandler);\nglobal.set(`${object_id}OccupancyRepository`, OccupancyRepository);\nglobal.set(`${object_id}PresenceRepository`, PresenceRepository);\nglobal.set(`${object_id}SourceRepository`, SourceRepository);\nglobal.set(`${object_id}EntitiesRepository`, EntitiesRepository);\nglobal.set(`${object_id}AreasRepository`, AreasRepository);\nglobal.set(`${object_id}DevicesRepository`, DevicesRepository);\n\n// Ports\nconst ports = {\n    motionSensorPort\n};\nglobal.set(`${object_id}motionSensorPort`, motionSensorPort);\n\n// Adapters\nconst adapters = {};\n\n// Domain\nconst domain = {\n    MotionEvent,\n    motionDetectionHandler,\n    OccupancyRepository,\n    PresenceRepository,\n\n};\n\n// General\nconst util = {};\n\nconst utils = {\n    adapters,\n    domain,\n    ports,\n    util\n};\n\nvar loaded = false;\nvar gc = global.keys();\n\n// Check if utils object is loaded\nfor (let i = 0; i < gc.length; i++) {\n\n    if (gc[i] === UTILS.OBJECT) loaded = true;\n\n}\n\n//global.set(`${SOURCE.REPOSITORY}${UTILS.OBJECT}`, utils);\n\n// load functionGlobalContext import\n//global.set(SOURCE.OBJECT, context.global[SOURCE.OBJECT]);\nconst MODULE_ID = env.get(\"MODULE_ID\");\nglobal.set(MODULE_ID, context.global[MODULE_ID]);\n\n// Return loaded status\nif (loaded) return status(`Utility Functions Loaded [${UTILS.OBJECT}]`);\n\n// Return non-loaded status\nreturn status(`Utility Functions Not loaded [${UTILS.OBJECT}]`);","outputs":1,"timeout":"","noerr":101,"initialize":"","finalize":"","libs":[],"x":760,"y":260,"wires":[[]]},{"id":"d4d95936d311f239","type":"subflow","name":"On Deploy / Change","info":"","category":"","in":[],"out":[{"x":500,"y":40,"wires":[{"id":"a440ba7d0d85e617","port":0}]}],"env":[{"name":"PATH","type":"str","value":"\"\""}],"meta":{},"color":"#DDAA99","status":{"x":720,"y":120,"wires":[{"id":"ac9387e713ce0715","port":0}]}},{"id":"a440ba7d0d85e617","type":"change","z":"d4d95936d311f239","name":"Set Timestamp / Path","rules":[{"t":"set","p":"payload","pt":"msg","to":"","tot":"date"},{"t":"set","p":"path","pt":"msg","to":"PATH","tot":"env"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":80,"wires":[["ac9387e713ce0715"]]},{"id":"a9b88fac6ee81cda","type":"watch","z":"d4d95936d311f239","name":"On Change [flows]","files":"/config/flows.json","recursive":"","x":110,"y":120,"wires":[["a440ba7d0d85e617"]]},{"id":"8a3ff4c90a5343b1","type":"inject","z":"d4d95936d311f239","name":"On Full Deploy","props":[],"repeat":"","crontab":"","once":true,"onceDelay":"1","topic":"","x":120,"y":40,"wires":[["a440ba7d0d85e617"]]},{"id":"ac9387e713ce0715","type":"function","z":"d4d95936d311f239","name":"Display Readable Date","func":"// Display Readable Date\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : deploy timestamp\n//\n// -*- OUTPUTS -*-\n// msg.payload              : datetime string\n// ******************************************************************\n\n/*** START ***/\nconst system = context.global[env.get(\"MODULE_ID\")];\nconst utils = system.util.common;\n\nconst last_deployed = new Date(msg.payload);\nmsg.payload = last_deployed.toLocaleString();\n\nreturn msg;\n/*** END ***/\n\n/*** HELPERS ***/\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":580,"y":120,"wires":[[]]},{"id":"d45c7673c797b311","type":"subflow","name":"Set Global Context","info":"","category":"","in":[{"x":40,"y":80,"wires":[{"id":"608f5fe6073b967a"}]}],"out":[{"x":340,"y":40,"wires":[{"id":"608f5fe6073b967a","port":0}]}],"env":[],"meta":{},"color":"#DDAA99","status":{"x":340,"y":120,"wires":[{"id":"608f5fe6073b967a","port":0}]}},{"id":"608f5fe6073b967a","type":"function","z":"d45c7673c797b311","name":"Set Global Context","func":"// Set Global Context\n// Just a function template..\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : current entity state value\n// msg.global_id            : Global Context identifier / Entity ID\n//\n// -*- OUTPUTS -*-\n// msg.payload              : global variable value\n// msg.global_id            : Actual Global Context identifier\n// ******************************************************************\n\n/*** START ***/\n//const utils = global.get(env.get(\"UTIL\") || \"system.util\");\n//node.warn(utils);\nglobal.set(msg.global_id, msg.payload);\n\nreturn msg;\n/*** END ***/\n\n/*** HELPER FUNCTIONS ***/\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":170,"y":80,"wires":[[]]},{"id":"a2c7f948590ba62d","type":"subflow","name":"Map Array To Object By Key","info":"","category":"","in":[{"x":0,"y":80,"wires":[{"id":"78536c8ec5ab7842"}]}],"out":[{"x":400,"y":80,"wires":[{"id":"78536c8ec5ab7842","port":0}]}],"env":[],"meta":{},"color":"#DDAA99","status":{"x":400,"y":160,"wires":[{"id":"78536c8ec5ab7842","port":1}]}},{"id":"78536c8ec5ab7842","type":"function","z":"a2c7f948590ba62d","name":"Map Array To Object By Key","func":"// Map Array To Object By Key (v1.1)\n// Maps an Array of objects to an object of objects by a given key\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload.data         : Object array\n// msg.payload.key          : Entity ID\n//\n// -*- OUTPUTS -*-\n// msg.payload              : Mapped object\n// ******************************************************************\n\n/*** START ***/\nconst system = context.global[env.get(\"MODULE_ID\")];\nconst utils = system.util.common;\n\nvar entities = msg.payload.data;\nvar key = msg.payload.key;\n\n// Return error if entities not provided\nif (!utils.exists(entities)) {\n    return [null, utils.status(\"Entities not provided\")];\n}\n\n// Return error if key not provided\nif (!utils.exists(key)) {\n    return [null, utils.status(\"Key not provided\")];\n}\n\nconst entityDictionary = utils.mapArrayToDict(entities, key);\nmsg.payload = entityDictionary;\n\nreturn [msg, utils.status(entityDictionary)]; \n/*** END ***/\n\n/*** HELPER FUNCTIONS ***/","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":200,"y":80,"wires":[[],[]]},{"id":"bcd1b01f6fd36df1","type":"subflow","name":"Check Path","info":"","category":"","in":[{"x":60,"y":80,"wires":[{"id":"ad7c503c87950fff"}]}],"out":[{"x":340,"y":40,"wires":[{"id":"ad7c503c87950fff","port":0}]},{"x":340,"y":120,"wires":[{"id":"ad7c503c87950fff","port":1}]}],"env":[{"name":"FILE_PATH","type":"str","value":""}],"meta":{},"color":"#DDAA99","status":{"x":340,"y":120,"wires":[{"id":"ad7c503c87950fff","port":1}]}},{"id":"ad7c503c87950fff","type":"function","z":"bcd1b01f6fd36df1","name":"Check Path","func":"// Check Path\n// Ensures a path has been passed\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.[payload.]path       : file path\n//\n// -*- OUTPUTS -*-\n// msg.payload              : global variable value\n// ******************************************************************\n\n/*** START ***/\nconst utils = context.global[env.get(\"MODULE_ID\")].util.common;\n\nconst path = env.get(\"FILE_PATH\") || (msg.payload ? msg.payload.path : false) || msg.path;\n\nif (!path) return [null, utils.status(\"Invalid path\", { fill: \"red\" })];\n\nmsg.path = path;\nreturn [msg, utils.status(msg.path)];","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":210,"y":80,"wires":[[],[]]},{"id":"a5ba79dede304e04","type":"subflow","name":"Load FIle","info":"","category":"","in":[{"x":40,"y":120,"wires":[{"id":"6dbbf8ae26143cab"}]}],"out":[{"x":440,"y":40,"wires":[{"id":"397f503f1150c2cd","port":0}]},{"x":620,"y":120,"wires":[{"id":"4cc02f131764b437","port":0},{"id":"6dbbf8ae26143cab","port":1}]}],"env":[{"name":"FILE_PATH","type":"str","value":""}],"meta":{},"color":"#DDAA99","status":{"x":620,"y":120,"wires":[{"id":"4cc02f131764b437","port":0},{"id":"6dbbf8ae26143cab","port":1}]}},{"id":"397f503f1150c2cd","type":"file in","z":"a5ba79dede304e04","name":"Load File","filename":"path","filenameType":"msg","format":"utf8","chunk":false,"sendError":false,"encoding":"none","allProps":false,"x":320,"y":80,"wires":[["4cc02f131764b437"]]},{"id":"4cc02f131764b437","type":"change","z":"a5ba79dede304e04","name":"Emit: Loaded","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"fill\":\"green\",\"text\":\"File Loaded\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":490,"y":80,"wires":[[]]},{"id":"6dbbf8ae26143cab","type":"subflow:bcd1b01f6fd36df1","z":"a5ba79dede304e04","name":"","x":170,"y":120,"wires":[["397f503f1150c2cd"],[]]},{"id":"bd6afb792041214f","type":"subflow","name":"Load Object File","info":"takes a msg.payload.path property","category":"","in":[{"x":40,"y":140,"wires":[{"id":"81d2e25bf7ee74d1"}]}],"out":[{"x":680,"y":60,"wires":[{"id":"576e7618aa1c1f3c","port":0}]}],"env":[{"name":"PATH","type":"str","value":""}],"meta":{},"color":"#DDAA99","status":{"x":680,"y":140,"wires":[{"id":"576e7618aa1c1f3c","port":1},{"id":"81d2e25bf7ee74d1","port":1},{"id":"825e840c9fccbb3e","port":0}]}},{"id":"1ee26ee40bc9de64","type":"json","z":"bd6afb792041214f","name":"Convert JSON to Object","property":"payload","action":"obj","pretty":false,"x":350,"y":100,"wires":[["576e7618aa1c1f3c"]]},{"id":"576e7618aa1c1f3c","type":"function","z":"bd6afb792041214f","name":"Store Object","func":"// Function Template (v1.1)\n// Just a function template..\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload.data         : file data\n// msg.global_id            : Global Context identifier / Entity ID\n//\n// -*- OUTPUTS -*-\n// msg.payload              : global variable value\n// msg.global_id            : Actual Global Context identifier\n// ******************************************************************\n\n/*** START ***/\nconst utils = context.global[env.get(\"MODULE_ID\")].util.common;\nconst fileName = utils.getFileNameFromPath(msg.filename);\nconst file_data = msg.payload.data;\n\nif (!utils.exists(file_data)) {\n\n    // Return non-loaded status\n    return [null, utils.status(\"Object Not loaded [\" + fileName + \"]\")];\n\n}\n\nmsg.payload = file_data;\n\n// Return loaded status\nreturn [msg, utils.status(\"Object loaded [\" + fileName + \"]\")];\n\n/*** END ***/\n\n/*** HELPER FUNCTIONS ***/\n","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":550,"y":100,"wires":[[],[]]},{"id":"81d2e25bf7ee74d1","type":"subflow:a5ba79dede304e04","z":"bd6afb792041214f","name":"","x":140,"y":140,"wires":[["1ee26ee40bc9de64"],[]]},{"id":"825e840c9fccbb3e","type":"catch","z":"bd6afb792041214f","name":"","scope":null,"uncaught":false,"x":560,"y":180,"wires":[[]]},{"id":"2e1553480c579f63","type":"subflow","name":"Load Registry Objects","info":"","category":"","in":[{"x":20,"y":640,"wires":[{"id":"3996fb557dbf8c0e"},{"id":"9798a6f4df86f7d9"}]}],"out":[{"x":1580,"y":540,"wires":[{"id":"38974f690d80b041","port":0}]}],"env":[{"name":"GLOBAL_ID","type":"str","value":"core"}],"meta":{},"color":"#DDAA99","status":{"x":1580,"y":700,"wires":[{"id":"222908029ced3859","port":0}]}},{"id":"bcb4a31424ba5497","type":"subflow:bd6afb792041214f","z":"2e1553480c579f63","d":true,"name":"Load Entity Registry","env":[{"name":"PATH","value":"/config/.storage/core.entity_registry","type":"str"}],"x":500,"y":40,"wires":[["815102ad2b31671f"]]},{"id":"815102ad2b31671f","type":"change","z":"2e1553480c579f63","d":true,"name":"Set Key/Value [entities]","rules":[{"t":"set","p":"payload.key","pt":"msg","to":"entity_id","tot":"str"},{"t":"set","p":"payload.data","pt":"msg","to":"payload.entities","tot":"msg"},{"t":"set","p":"global_id","pt":"msg","to":"$env(\"GLOBAL_ID\")  & \".entities\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":730,"y":40,"wires":[["217f75e7bca461a3"]]},{"id":"217f75e7bca461a3","type":"subflow:a2c7f948590ba62d","z":"2e1553480c579f63","d":true,"name":"","x":980,"y":40,"wires":[["36d5902f29e6e9ea"]]},{"id":"36d5902f29e6e9ea","type":"subflow:d45c7673c797b311","z":"2e1553480c579f63","d":true,"name":"","x":1210,"y":40,"wires":[["c4784f18be989d10"]]},{"id":"5ea2ef5950bcd15f","type":"subflow:bd6afb792041214f","z":"2e1553480c579f63","d":true,"name":"Load Area Registry","env":[{"name":"PATH","value":"/config/.storage/core.area_registry","type":"str"}],"x":490,"y":100,"wires":[["55e22fc14282a3e8"]]},{"id":"55e22fc14282a3e8","type":"change","z":"2e1553480c579f63","d":true,"name":"Set Key/Value [areas]","rules":[{"t":"set","p":"payload.key","pt":"msg","to":"id","tot":"str"},{"t":"set","p":"payload.data","pt":"msg","to":"payload.areas","tot":"msg"},{"t":"set","p":"global_id","pt":"msg","to":"$env(\"GLOBAL_ID\") & \".areas\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":720,"y":100,"wires":[["f8137a9c5ea57731"]]},{"id":"f8137a9c5ea57731","type":"subflow:a2c7f948590ba62d","z":"2e1553480c579f63","d":true,"name":"","x":980,"y":100,"wires":[["94b3eebd3b0a1efb"]]},{"id":"94b3eebd3b0a1efb","type":"subflow:d45c7673c797b311","z":"2e1553480c579f63","d":true,"name":"","x":1210,"y":100,"wires":[["c4784f18be989d10"]]},{"id":"eb00dc26780a4a14","type":"subflow:bd6afb792041214f","z":"2e1553480c579f63","d":true,"name":"Load Device Registry","env":[{"name":"PATH","value":"/config/.storage/core.device_registry","type":"str"}],"x":500,"y":160,"wires":[["8b044605b6354c5e"]]},{"id":"8b044605b6354c5e","type":"change","z":"2e1553480c579f63","d":true,"name":"Set Key/Value [devices]","rules":[{"t":"set","p":"payload.key","pt":"msg","to":"id","tot":"str"},{"t":"set","p":"payload.data","pt":"msg","to":"payload.devices","tot":"msg"},{"t":"set","p":"global_id","pt":"msg","to":"$env(\"GLOBAL_ID\")  & \".devices\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":730,"y":160,"wires":[["fb65ea3d70e285e5"]]},{"id":"fb65ea3d70e285e5","type":"subflow:a2c7f948590ba62d","z":"2e1553480c579f63","d":true,"name":"","x":980,"y":160,"wires":[["9d3d5380a92cb219"]]},{"id":"9d3d5380a92cb219","type":"subflow:d45c7673c797b311","z":"2e1553480c579f63","d":true,"name":"","x":1210,"y":160,"wires":[["c4784f18be989d10"]]},{"id":"305a08ebae857d4a","type":"subflow:d4d95936d311f239","z":"2e1553480c579f63","d":true,"name":"","env":[{"name":"PATH","value":"/config/node-red/flows.json","type":"str"}],"x":230,"y":100,"wires":[["bcb4a31424ba5497","5ea2ef5950bcd15f","eb00dc26780a4a14","e45e996a9a1bf798"]]},{"id":"c4784f18be989d10","type":"join","z":"2e1553480c579f63","d":true,"name":"","mode":"custom","build":"object","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":1450,"y":100,"wires":[["f2fe2c6b5b0374d1"]]},{"id":"e45e996a9a1bf798","type":"delay","z":"2e1553480c579f63","d":true,"name":"","pauseType":"delay","timeout":"5","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"allowrate":false,"outputs":1,"x":440,"y":220,"wires":[["8c80d84bc4397cfb"]]},{"id":"f2fe2c6b5b0374d1","type":"change","z":"2e1553480c579f63","d":true,"name":"Success","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"payload","pt":"msg","to":"{\"payload\":{\"text\":\"Registry Objects Loaded\",\"fill\":\"green\"}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":440,"y":300,"wires":[["e45e996a9a1bf798","24873dee86d7e1f7"]]},{"id":"8c80d84bc4397cfb","type":"change","z":"2e1553480c579f63","d":true,"name":"Error","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"payload\":{\"text\":\"Error Loading Registry Objects\",\"fill\":\"red\"}}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":810,"y":220,"wires":[["f85ab3b9f532fa3b"]]},{"id":"8f33ea59b682ec9a","type":"api-render-template","z":"2e1553480c579f63","name":"Load Entity Registry","server":"3edfacf2.b3d2c4","version":0,"template":"entity_id,domain,object_id,name,area_id,area_name,icon,device_class,unit_of_measurement,labels\n{%- for state in states %}\n{{ state.entity_id }},{{ state.domain }},{{ state.object_id }},\"{{ state.name }}\",\"{{ area_id(state.entity_id) }}\",\"{{ area_name(state.entity_id) }}\",\"{{ state_attr(state.entity_id,'icon') }}\",\"{{ state_attr(state.entity_id,'device_class') }}\",\"{{ state_attr(state.entity_id,'unit_of_measurement') }}\",\"{{ labels(state.entity_id) }}\"\n{%- endfor -%}\n{# The minus sign - after the first curly brace percent sign {% will remove preceding whitespace (in this case, eliminate a blank line between the headers and the data) #}","resultsLocation":"payload","resultsLocationType":"msg","templateLocation":"","templateLocationType":"none","x":460,"y":500,"wires":[["2bddda0ee4eb4589"]]},{"id":"99b436b8fbb33c3a","type":"csv","z":"2e1553480c579f63","name":"","sep":",","hdrin":true,"hdrout":"none","multi":"mult","ret":"\\n","temp":"Load Entities","skip":"0","strings":true,"include_empty_strings":true,"include_null_values":true,"x":630,"y":580,"wires":[["e1407f5e437e8bdb"]]},{"id":"174a98c9608b57a7","type":"api-render-template","z":"2e1553480c579f63","name":"Load Area Registry","server":"3edfacf2.b3d2c4","version":0,"template":"name,id,floor_id,labels\n{%- for area in areas() %}\n\"{{ area_name(area) }}\",\"{{ area }}\",\"{{ floor_id(area) }}\",\"{{ labels(area) }}\"\n{%- endfor -%}\n{# The minus sign - after the first curly brace percent sign {% will remove preceding whitespace (in this case, eliminate a blank line between the headers and the data) #}","resultsLocation":"payload","resultsLocationType":"msg","templateLocation":"","templateLocationType":"none","x":450,"y":580,"wires":[["99b436b8fbb33c3a"]]},{"id":"2bddda0ee4eb4589","type":"csv","z":"2e1553480c579f63","name":"","sep":",","hdrin":true,"hdrout":"none","multi":"mult","ret":"\\n","temp":"Load Entities","skip":"0","strings":true,"include_empty_strings":true,"include_null_values":true,"x":630,"y":500,"wires":[["967b4a4077b1a1c7"]]},{"id":"967b4a4077b1a1c7","type":"change","z":"2e1553480c579f63","name":"","rules":[{"t":"set","p":"core.entity_registry","pt":"global","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":820,"y":500,"wires":[["cf6fe308ba288438"]]},{"id":"e1407f5e437e8bdb","type":"change","z":"2e1553480c579f63","name":"","rules":[{"t":"set","p":"core.area_registry","pt":"global","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":820,"y":580,"wires":[["c91c7759540f510a"]]},{"id":"cf6fe308ba288438","type":"file","z":"2e1553480c579f63","name":"","filename":"/config/.storage/core.entity_registry","filenameType":"str","appendNewline":false,"createDir":true,"overwriteFile":"true","encoding":"none","x":1140,"y":500,"wires":[["38974f690d80b041"]]},{"id":"c91c7759540f510a","type":"file","z":"2e1553480c579f63","name":"","filename":"/config/.storage/core.area_registry","filenameType":"str","appendNewline":false,"createDir":true,"overwriteFile":"true","encoding":"none","x":1140,"y":580,"wires":[["38974f690d80b041"]]},{"id":"38974f690d80b041","type":"join","z":"2e1553480c579f63","name":"Load Core Registry","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":false,"timeout":"","count":"3","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":1420,"y":540,"wires":[["c5b584389b5e263c","f9a2ace897798fb9"]]},{"id":"f9a2ace897798fb9","type":"change","z":"2e1553480c579f63","name":"","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"}],"action":"","property":"","from":"","to":"","reg":false,"x":1640,"y":580,"wires":[["3c22eb669069296f"]]},{"id":"3996fb557dbf8c0e","type":"subflow:a7ed881353992217","z":"2e1553480c579f63","name":"","x":190,"y":580,"wires":[["e96b993ff89bfa0d"],["00d14ca14ed78d84"]]},{"id":"c5b584389b5e263c","type":"change","z":"2e1553480c579f63","name":"Emit: Loaded","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"fill\":\"green\",\"text\":\"Registries Loaded\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":1630,"y":500,"wires":[["e02257877bd713ca"]]},{"id":"33b9c0273f6c8e6d","type":"delay","z":"2e1553480c579f63","name":"","pauseType":"delay","timeout":"10","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"allowrate":false,"outputs":1,"x":540,"y":700,"wires":[["edd20d835e81cc30"]]},{"id":"edd20d835e81cc30","type":"change","z":"2e1553480c579f63","name":"Emit: Not Loaded","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"fill\":\"red\",\"text\":\"Error Loading Registries\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":710,"y":700,"wires":[["ce234410e56d72cf"]]},{"id":"9798a6f4df86f7d9","type":"change","z":"2e1553480c579f63","name":"Delete delay properties","rules":[{"t":"delete","p":"reset","pt":"msg"},{"t":"delete","p":"flush","pt":"msg"},{"t":"delete","p":"rate","pt":"msg"},{"t":"delete","p":"delay","pt":"msg"},{"t":"delete","p":"toFront","pt":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":210,"y":700,"wires":[["33b9c0273f6c8e6d"]]},{"id":"2622bfe4c9b4e1d6","type":"json","z":"2e1553480c579f63","name":"","property":"payload","action":"","pretty":false,"x":630,"y":540,"wires":[["8324ba06074d1161"]]},{"id":"ae318a02085126db","type":"api-render-template","z":"2e1553480c579f63","name":"Load Domain Registry","server":"3edfacf2.b3d2c4","version":0,"template":"{{ states | map(attribute='domain') | unique | list | tojson }}","resultsLocation":"payload","resultsLocationType":"msg","templateLocation":"","templateLocationType":"none","x":460,"y":540,"wires":[["2622bfe4c9b4e1d6"]]},{"id":"8324ba06074d1161","type":"change","z":"2e1553480c579f63","name":"","rules":[{"t":"set","p":"core.domain_registry","pt":"global","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":830,"y":540,"wires":[["374b2020bc2f8fb9"]]},{"id":"374b2020bc2f8fb9","type":"file","z":"2e1553480c579f63","name":"","filename":"/config/.storage/core.domain_registry","filenameType":"str","appendNewline":false,"createDir":true,"overwriteFile":"true","encoding":"none","x":1130,"y":540,"wires":[["38974f690d80b041"]]},{"id":"00d14ca14ed78d84","type":"link out","z":"2e1553480c579f63","name":"Status IN","mode":"link","links":["222908029ced3859"],"x":380,"y":620,"wires":[],"l":true},{"id":"222908029ced3859","type":"link in","z":"2e1553480c579f63","name":"Status OUT","links":["00d14ca14ed78d84","ce234410e56d72cf","e02257877bd713ca","24873dee86d7e1f7","f85ab3b9f532fa3b"],"x":1470,"y":700,"wires":[[]],"l":true},{"id":"ce234410e56d72cf","type":"link out","z":"2e1553480c579f63","name":"Status IN","mode":"link","links":["222908029ced3859"],"x":880,"y":700,"wires":[],"l":true},{"id":"e02257877bd713ca","type":"link out","z":"2e1553480c579f63","name":"Status IN","mode":"link","links":["222908029ced3859"],"x":1780,"y":500,"wires":[],"l":true},{"id":"24873dee86d7e1f7","type":"link out","z":"2e1553480c579f63","d":true,"name":"Status IN","mode":"link","links":["222908029ced3859"],"x":633.765625,"y":299.75,"wires":[],"l":true},{"id":"f85ab3b9f532fa3b","type":"link out","z":"2e1553480c579f63","d":true,"name":"Status IN","mode":"link","links":["222908029ced3859"],"x":940,"y":220,"wires":[],"l":true},{"id":"3c22eb669069296f","type":"link out","z":"2e1553480c579f63","name":"Delay IN","mode":"link","links":["cb92fcb9edda4c44"],"x":1800,"y":580,"wires":[],"l":true},{"id":"cb92fcb9edda4c44","type":"link in","z":"2e1553480c579f63","name":"Delay OUT","links":["3c22eb669069296f"],"x":380,"y":660,"wires":[["33b9c0273f6c8e6d"]],"l":true},{"id":"e96b993ff89bfa0d","type":"junction","z":"2e1553480c579f63","x":320,"y":540,"wires":[["ae318a02085126db","8f33ea59b682ec9a","174a98c9608b57a7"]]},{"id":"3edfacf2.b3d2c4","type":"server","name":"Home Assistant","addon":true},{"id":"a7ed881353992217","type":"subflow","name":"Wait For Connect","info":"","category":"","in":[{"x":40,"y":120,"wires":[{"id":"1042b76e40019466"},{"id":"86234a2687e886f7"},{"id":"3439324a028c5b9c"}]}],"out":[{"x":1120,"y":40,"wires":[{"id":"d741dbefd42198f3","port":0}]},{"x":1120,"y":260,"wires":[{"id":"86234a2687e886f7","port":0},{"id":"539d94557d2886db","port":0}]}],"env":[],"meta":{},"color":"#DDAA99","status":{"x":1120,"y":200,"wires":[{"id":"86234a2687e886f7","port":0},{"id":"539d94557d2886db","port":0}]}},{"id":"86234a2687e886f7","type":"change","z":"a7ed881353992217","name":"Emit: Connecting...","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"fill\":\"yellow\",\"text\":\"Connecting...\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":230,"y":200,"wires":[[]]},{"id":"3439324a028c5b9c","type":"delay","z":"a7ed881353992217","name":"","pauseType":"delay","timeout":"10","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"allowrate":false,"outputs":1,"x":580,"y":120,"wires":[["06986f1ce890459f"]]},{"id":"8f96fab0f6a08024","type":"server-state-changed","z":"a7ed881353992217","name":"On Connect","server":"5e6a682a.ce8468","version":5,"outputs":1,"exposeAsEntityConfig":"","entityId":"input_boolean.is_connected","entityIdType":"exact","outputInitially":true,"stateType":"str","ifState":"","ifStateType":"str","ifStateOperator":"is","outputOnlyOnStateChange":true,"for":"","forType":"num","forUnits":"minutes","ignorePrevStateNull":false,"ignorePrevStateUnknown":false,"ignorePrevStateUnavailable":false,"ignoreCurrentStateUnknown":false,"ignoreCurrentStateUnavailable":false,"outputProperties":[{"property":"flush","propertyType":"msg","value":"true","valueType":"bool"}],"x":410,"y":160,"wires":[["3439324a028c5b9c"]]},{"id":"1042b76e40019466","type":"api-current-state","z":"a7ed881353992217","name":"Is Connected","server":"5e6a682a.ce8468","version":3,"outputs":1,"halt_if":"","halt_if_type":"str","halt_if_compare":"is","entity_id":"input_boolean.is_connected","state_type":"str","blockInputOverrides":false,"outputProperties":[],"for":"","forType":"num","forUnits":"minutes","override_topic":false,"state_location":"payload","override_payload":"msg","entity_location":"data","override_data":"msg","x":210,"y":40,"wires":[["5c86e3b0483a60ad","d741dbefd42198f3"]]},{"id":"5c86e3b0483a60ad","type":"change","z":"a7ed881353992217","name":"","rules":[{"t":"set","p":"reset","pt":"msg","to":"true","tot":"bool"}],"action":"","property":"","from":"","to":"","reg":false,"x":400,"y":80,"wires":[["3439324a028c5b9c"]]},{"id":"06986f1ce890459f","type":"change","z":"a7ed881353992217","name":"","rules":[{"t":"delete","p":"flush","pt":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":740,"y":120,"wires":[["d741dbefd42198f3"]]},{"id":"d741dbefd42198f3","type":"change","z":"a7ed881353992217","name":"Send Payload","rules":[],"action":"","property":"","from":"","to":"","reg":false,"x":960,"y":40,"wires":[["539d94557d2886db"]]},{"id":"539d94557d2886db","type":"change","z":"a7ed881353992217","name":"Emit: Conneced","rules":[{"t":"set","p":"payload","pt":"msg","to":"{\"fill\":\"green\",\"text\":\"Connected\"}","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":960,"y":160,"wires":[[]]},{"id":"735ef8c1f49956e2","type":"catch","z":"a7ed881353992217","name":"Catch: Is (not) Connected","scope":["1042b76e40019466"],"uncaught":false,"x":130,"y":280,"wires":[["22150e1e5bc97273"]]},{"id":"22150e1e5bc97273","type":"debug","z":"a7ed881353992217","d":true,"name":"Catch: Is (not) Connected","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":370,"y":280,"wires":[]},{"id":"20b25024f4366686","type":"subflow","name":"Event Poller","info":"","category":"","in":[{"x":40,"y":120,"wires":[{"id":"70a50ced4a3dc70b"}]}],"out":[{"x":800,"y":40,"wires":[{"id":"ec2364ce90addde6","port":0}]}],"env":[{"name":"POLL_RATE","type":"env","value":"POLL_RATE"},{"name":"POLL_RATE_MULTIPLIER","type":"num","value":"1"}],"meta":{},"color":"#DDAA99","status":{"x":520,"y":120,"wires":[{"id":"d8ca55012a5de042","port":1},{"id":"70a50ced4a3dc70b","port":1}]}},{"id":"d8ca55012a5de042","type":"function","z":"20b25024f4366686","name":"Event Poller 1.5","func":"// Event Poller (v1.5)\n// Event Poller\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.reset                    : flag to stop polling\n// msg.delay || env.POLL_RATE   : Entity/Global ID || delay value\n//\n// -*- OUTPUTS -*-\n// msg.payload                  : existing message payload\n// msg.delay                    : delay value in milliseconds\n// ******************************************************************\n\n/*** START ***/\nconst repository = context.global[env.get(\"MODULE_ID\")];\nconst utils = repository.util.common;\nconst { TimeoutConverter } = repository.domain.models;\n\n// Reset existing timers\nnode.send([{reset:true}, null]);\n\n// Pass on reset flag if found\nif (msg.reset) return [msg, utils.status(\"RESET\")];\n\nconst poll_rate = env.get(\"POLL_RATE\");\n\nif (!poll_rate && !msg.delay) return ([null, utils.status(`[ERROR] Missing msg.delay|$POLL_RATE: ${msg.delay}|${poll_rate}`, { fill: \"red\" })]);\n\ntry {\n\n    // Check if msg.delay or $POLL_RATE was passed\n    msg.delay = msg.delay ? msg.delay : poll_rate;\n\n    const delay_entity_state = global.get(`homeassistant.homeAssistant.states['${msg.delay}']`);\n\n    // Check if positive integer value was passed\n    if (typeof msg.delay === \"number\" && msg.delay > 0) {\n    // Continue\n\n    // Check if entity ID was passed\n    } else if (delay_entity_state) {\n        \n        msg.delay = TimeoutConverter.convertToMilliseconds(delay_entity_state.state, delay_entity_state.attributes.unit_of_measurement);\n\n    // Should be a global context ID\n    } else {\n        msg.delay = TimeoutConverter.convertTimeoutString(global.get(msg.delay));\n    }\n\n    if (!msg.delay) return ([null, utils.status(`[ERROR] Invalid msg.delay|$POLL_RATE: ${msg.delay}|${poll_rate}`, { fill: \"red\" })]);;\n\n    // Apply multiplier if present\n    const multiplier = env.get(\"POLL_RATE_MULTIPLIER\") || 1;\n    console.log(`MULTIPLIER: ${multiplier}`);\n    msg.delay = msg.delay * multiplier;\n\n    return [msg, utils.status(`${msg.delay} milliseconds`)];\n\n} catch (error) {\n    return ([null, utils.status(`Error retrieving msg.delay|$POLL_RATE: ${error.message}`, { fill: \"red\" })]);\n}\n\n/*** END ***/","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":380,"y":80,"wires":[["ec2364ce90addde6"],[]]},{"id":"ec2364ce90addde6","type":"trigger","z":"20b25024f4366686","name":"resend every msg.delay || 60s","op1":"","op2":"0","op1type":"pay","op2type":"str","duration":"-60","extend":true,"overrideDelay":true,"units":"s","reset":"","bytopic":"all","topic":"topic","outputs":1,"x":630,"y":40,"wires":[[]]},{"id":"70a50ced4a3dc70b","type":"subflow:a7ed881353992217","z":"20b25024f4366686","name":"","x":170,"y":120,"wires":[["d8ca55012a5de042"],[]]},{"id":"416f3e9048b97ca4","type":"subflow","name":"Presence Updater","info":"","category":"","in":[{"x":40,"y":80,"wires":[{"id":"3a68e43ab36d25e9"}]}],"out":[{"x":380,"y":40,"wires":[{"id":"3a68e43ab36d25e9","port":0}]}],"env":[],"meta":{},"color":"#DDAA99","status":{"x":380,"y":120,"wires":[{"id":"3a68e43ab36d25e9","port":1}]}},{"id":"3a68e43ab36d25e9","type":"function","z":"416f3e9048b97ca4","name":"User Presence Updater","func":"// User Presence Updater\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : Person event data\n//\n// -*- OUTPUTS -*-\n// msg.payload              : PresenceService object\n// ******************************************************************\n\n/*** START ***/\nconst repository = context.global[env.get(\"MODULE_ID\")];\nconst utils = repository.util.common;\nconst PresenceEvent = repository.domain.models.PresenceEvent;\nconst PresenceService = repository.domain.services.PresenceService;\n\nlet status;\n\ntry {\n\n    status = \"Updating presence...\";\n    node.status({ fill: \"yellow\", text: status });\n\n    // Extract the presence event data\n    const presenceEvent = new PresenceEvent(msg.payload);\n\n    // Update the presence status\n    msg.payload = PresenceService.setPresence(presenceEvent);\n\n    status = `Presence updated (${presenceEvent.getUser()})`;\n    node.status(utils.status(status).payload);\n\n    // Return the updated PresenceService object\n    return [msg, utils.status(status)];\n\n} catch (error) {\n    // Log the error\n    node.warn(`[ERROR (PresenceService)]: ${error}`);\n\n    // Set node status to indicate an error occurred\n    status = `Error updating presence object: ${error}`;\n\n    node.status({ fill: \"red\", text: status });\n    return [null, utils.status(status, { fill: \"red\" })];\n}\n\n\n/*** END ***/","outputs":2,"timeout":"","noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is started.\nnode.status({ fill: \"yellow\", shape: \"dot\", text: \"Starting...\" });","finalize":"","libs":[],"x":190,"y":80,"wires":[[],[]]},{"id":"db47d8fece13615c","type":"subflow","name":"Occupancy State Updater","info":"","category":"","in":[{"x":20,"y":80,"wires":[{"id":"1d52c466c78f7745"}]}],"out":[{"x":380,"y":40,"wires":[{"id":"1d52c466c78f7745","port":0}]}],"env":[{"name":"OCCUPANCY_TIMEOUT_ENTITY_ID","type":"str","value":"input_number.occupancy_timeout"}],"meta":{},"color":"#DDAA99","status":{"x":380,"y":120,"wires":[{"id":"1d52c466c78f7745","port":1}]}},{"id":"1d52c466c78f7745","type":"function","z":"db47d8fece13615c","name":"Occupancy State Updater","func":"// Occupancy State Updater\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : binary_sensor event data\n//\n// -*- OUTPUTS -*-\n// msg.payload              : OccupancyService object\n// ******************************************************************\n\n/*** START ***/\nconst repository = context.global[env.get(\"MODULE_ID\")];\nconst utils = repository.util.common;\nconst { getState, exists } = repository.util.common;\nconst { Entities, TimeoutConverter, OccupancyEvent } = repository.domain.models;\nconst OccupancyService = repository.domain.services.OccupancyService;\nconst binarySensorOccupancyAdapter = repository.adapters.binarySensorOccupancyAdapter;\n\nconst OCCUPANCY_TIMEOUT_ENTITY_ID = env.get(\"OCCUPANCY_TIMEOUT_ENTITY_ID\") || \"input_number.occupancy_timeout\";\n\nconst event_data = msg.payload;\nlet status, area_id, states;\n\nif (!exists(event_data)) {\n    status = `Missing event data (msg.payload): [${msg.payload}]`;\n    return [null, utils.status(status, \"red\")];\n}\n\ntry {\n    area_id = Entities.getEntity(event_data.entity_id).area_id;\n    states = global.get(\"homeassistant.homeAssistant.states\");\n\n    if (area_id) {\n        // Check for area occupancy timeout helper\n        const area_occupancy_timeout_entity = Entities.getEntityByAttributes(OCCUPANCY_TIMEOUT_ENTITY_ID, [{key:\"area_id\", value:area_id}]);\n\n        if (area_occupancy_timeout_entity) {\n            const timeout = getState(area_occupancy_timeout_entity.entity_id, states).state;\n            if (timeout) OccupancyService.setTimeout(TimeoutConverter.convertToMilliseconds(timeout, area_occupancy_timeout_entity.unit_of_measurement), area_id);\n            //node.warn(`[WARN]: ${OCCUPANCY_TIMEOUT_ENTITY_ID} found for ${area_id}:  ${area_occupancy_timeout_entity.entity_id}`);\n        } else {\n            //node.warn(`[WARN]: ${OCCUPANCY_TIMEOUT_ENTITY_ID} not found for ${area_id}, skipping.`);\n        }\n    }\n    // Check for (global) occupancy timeout helper\n    const occupancy_timeout_entity = Entities.getEntityByAttributes(OCCUPANCY_TIMEOUT_ENTITY_ID);\n\n    if (occupancy_timeout_entity) {\n        const timeout = getState(occupancy_timeout_entity.entity_id, states).state;\n        if (timeout) OccupancyService.setTimeout(TimeoutConverter.convertToMilliseconds(timeout, occupancy_timeout_entity.unit_of_measurement));\n        //node.warn(`[WARN]: ${OCCUPANCY_TIMEOUT_ENTITY_ID} found.`);\n    } else {\n        //node.warn(`[WARN]: ${OCCUPANCY_TIMEOUT_ENTITY_ID} not found, skipping.`);\n    }\n\n} catch (error) {\n    status = `[ERROR]: ${error}`;\n    node.warn(status);\n    return [null, utils.status(status, \"red\")];\n}\n\ntry {\n    node.send([null, utils.status(`Updating Occupancy for [${area_id}]...`, \"yellow\")]);\n    OccupancyService.setOccupancy(new OccupancyEvent(event_data));\n} catch (error) {\n    status = `[ERROR] (binarySensorOccupancyAdapter): ${error}`;\n    node.warn(status);\n    return [null, utils.status(status, \"red\")];\n}\n\nreturn ([msg, utils.status(`Occupancy updated for [${area_id}]`)]);","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":210,"y":80,"wires":[[],[]]},{"id":"1671b0eb36e8a5c9","type":"subflow","name":"String Time Conversion Function","info":"","category":"","in":[{"x":-20,"y":80,"wires":[{"id":"c6ca34d9.3892c8"}]}],"out":[{"x":400,"y":80,"wires":[{"id":"c6ca34d9.3892c8","port":0}]}],"env":[],"meta":{},"color":"#DDAA99","status":{"x":400,"y":20,"wires":[{"id":"c6ca34d9.3892c8","port":0}]}},{"id":"c6ca34d9.3892c8","type":"function","z":"1671b0eb36e8a5c9","name":"String Time Conversion Function (v1.5)","func":"//Time Conversion Routine v1.3\n//This routine takes strings such as \"5 Minutes\" and converts into \n//a usable DT format (ms for now, might add more options later)\n//milliseconds conversion\n//Seconds | 1000\n//Minutes | 60000\n//\n// Function Variables\nvar formattedTimeout    = 0;\nvar timeoutStr      = msg.payload.toString().split(\" \");\n//node.warn(\"timeoutStr: \"+ timeoutStr);\nvar timeoutValue    = getValue(timeoutStr[0]);\n//node.warn(\"timeoutValue: \"+ timeoutValue);\nvar timeoutUnit     = getUnit(timeoutStr[1]);\n//node.warn(\"timeoutUnit: \"+ timeoutUnit);\n\n// Conversion\nswitch(timeoutUnit) {\n  case \"S\":\n    // Seconds\n    formattedTimeout = timeoutValue * 1000;\n    break;\n  case \"M\":\n    // Minutes\n    formattedTimeout = timeoutValue * 60000;\n    break;\n  case \"H\":\n    // Hours\n    formattedTimeout = timeoutValue * 3600000;\n    break;\n  case \"D\":\n    // Hours\n    formattedTimeout = timeoutValue * 86400000;\n    break;\n  default:\n    // (Low/Medium/High/\"\") defaulting to minutes\n    formattedTimeout = timeoutValue * 1000;\n}\n//node.warn(\"formattedTimeout: \"+ formattedTimeout);\nmsg.payload = formattedTimeout;\nmsg.timeout = true;\nreturn msg;\n\n// Unit Retrieval Function\nfunction getUnit (unit){\n    //node.warn(\"getUnit\");\n    if (unit == undefined){\n        return \"\";\n    }\n  var units = \n  {\n    'seconds'   : 'S',\n    'second'    : 'S',\n    'minutes'   : 'M',\n    'minute'    : 'M',\n    'hours'     : 'H',\n    'hour'      : 'H',\n    'days'      : 'D',\n    'day'       : 'D'\n  };\n  return (units[unit.toLowerCase()] || \"\");\n}\nfunction getValue (value){\n    //node.warn(\"getValue\");\n  if (parseInt(value)){\n    //node.warn(\"Integer value: \" + value);  \n    return parseInt(value)\n  } else {\n    // Likely a string value\n    //node.warn(\"String value: \" + value);\n    var values = \n    {\n      'low'     : '15',\n      'medium'  : '30',\n      'high'    : '60',\n    };\n    //node.warn(values[value.toLowerCase()]);\n    return (values[value.toLowerCase()] || \"\");\n  }\n}","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":190,"y":80,"wires":[[]]},{"id":"e1011d7cb4a81c2f","type":"comment","z":"1671b0eb36e8a5c9","name":"","info":"add ability to take a string in the form:\n00:00:00:00\n\nshould allow for more precise intervals\n\ncan check for correct format by:\n\n1. string length = 12\n2. split by : gives 4 arrays\n3. each element should be parseint\n4. no negative numbers (no -5:10:20:30 etc)\n","x":250,"y":180,"wires":[]},{"id":"5c17ae8417803497","type":"subflow","name":"Global Context Mapper","info":"Maps entity state to global variable for automations\r\n\r\n\r\n### Inputs\r\n\r\n: payload (any)                 :  current entity state value\r\n: global_id (string)            :  Global Context identifier / Entity ID. \r\n: entities [OPTIONAL] (json)    :  Key/Value json mapping for input_select values (or anything else really)\r\n\r\n### Outputs\r\n\r\n1. Standard output\r\n: payload (any)         : global variable value\r\n: global_id (string)    : Global Context Variable identifier\r\n\r\n### Details\r\n\r\n`msg.payload` is used as the payload of the entity state.\r\n\r\n`msg.global_id` is used as the payload for the global context id. \r\n\r\nIf an Entity ID was provided, the entity type gets stripped from the resulting Global ID.\r\n\r\nFor example, Entity ID: light.`bedroom_light` becomes Global ID: `bedroom_light`\r\n\r\n`msg.entities` also takes a `default` key value pairing which is used when no other match is found.\r\n\r\nExisting paramters are unaffected, only `msg.payload` and `msg.global_id` are affected. \r\nHowever this may change in the future.\r\n\r\n### References\r\n\r\n - Author - SK\r\n - Current Version - 1.5","category":"","in":[{"x":-60,"y":80,"wires":[{"id":"525d918b5abc8b1f"}]}],"out":[{"x":1420,"y":60,"wires":[{"id":"d4d4a0610c74c3b0","port":0},{"id":"f0de75025c9049c4","port":0},{"id":"d01813745291ec33","port":0}]}],"env":[{"name":"GLOBAL_ID","type":"str","value":""}],"meta":{},"color":"#DDAA99","status":{"x":1420,"y":140,"wires":[{"id":"d4d4a0610c74c3b0","port":0},{"id":"f0de75025c9049c4","port":1},{"id":"d01813745291ec33","port":1}]}},{"id":"a78b7f16a9f2200f","type":"function","z":"5c17ae8417803497","d":true,"name":"Generic Input Select Entity Mapper (v1.2)","func":"// Generic Input Select Entity Mapper\n// Maps input_select text value to entity_id for automations\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload : current input_select value\n// msg.global_id : Context Data global identifier / Entity ID\n// msg.entities : Key/Value json mapping for input_select\n//\n// -*- OUTPUTS -*-\n// msg.payload : value entity mapping\n// msg.global_id : Actual Context Data global identifier\n// ******************************************************************\n// Function Variables\nvar inputSelectStr      = msg.payload;\nvar inputSelectEntity   = getEntity(inputSelectStr);\nvar global_id           = getGlobalID(msg.global_id);\nif (inputSelectEntity != \"\") {\n    // Set global variable\n    setGlobalVariable(global_id, inputSelectEntity);\n    // Return details in new msg\n    newMsg = { payload: inputSelectEntity};\n    newMsg = { global_id: global_id};\n    return newMsg;\n} else {\n    // Error? Log\n    node.warn('Invalid/Missing Entity Mapping: '+ msg.entities);\n    return null\n}\n///////////////////////////////////\n//END\n///////////////////////////////////\n//\n// Entity Retrieval Function (v1.0)\n//\nfunction getEntity (entityStr){\n  var entities = msg.entities;\n  if (entities == null) {\n        return \"\";\n  }\n  return (entities[entityStr.toLowerCase()] || \"\");\n}\n//\n// Global ID Retrieval Function (v1.1)\n//\nfunction getGlobalID (global_id){\n    //Check if entity_id was passed\n    if (global_id != null && global_id.split(\".\")) {\n        global_id = global_id.split(\".\")[1];\n    } else {\n        global_id = global_id;\n    }\n    // Return global value\n    return global_id;\n}\n//\n// Global Variable Setter Function (v1.0)\n//\nfunction setGlobalVariable (global_id, value){\n    // Set global value\n    global.set(global_id, value);\n    node.warn('Global Variable ['+ global_id +'] set to '+ value);\n}","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1200,"y":280,"wires":[[]]},{"id":"ed44987a61686368","type":"function","z":"5c17ae8417803497","d":true,"name":"Generic Input Select Entity Mapper (v1.4)","func":"// Generic Input Select Entity Mapper\n// Maps input_select text value to entity_id for automations\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload : current input_select value\n// msg.global_id : Context Data global identifier / Entity ID\n// msg.entities : Key/Value json mapping for input_select\n//\n// -*- OUTPUTS -*-\n// msg.payload : value entity mapping\n// msg.global_id : Actual Context Data global identifier\n// ******************************************************************\n// Function Variables\nvar inputSelectStr      = msg.payload;\nvar inputSelectEntity   = getEntity(inputSelectStr);\n//node.warn('inputSelectEntity: '+ inputSelectEntity);\nvar global_id           = getGlobalID(msg.global_id);\nif (inputSelectEntity != null) {\n    // Set global variable\n    setGlobalVariable(global_id, inputSelectEntity);\n    // Return details in new msg\n    var newMsg = { payload: inputSelectEntity};\n    newMsg.global_id = global_id;\n    return newMsg;\n} else {\n    // Error? Log\n    node.warn('Invalid/Missing Entity Mapping: '+ inputSelectEntity + ' please ensure mapping is lowercase');\n    return null\n}\n///////////////////////////////////\n//END\n///////////////////////////////////\n//\n// Entity Retrieval Function (v1.0)\n//\nfunction getEntity (entityStr){\n  var entities = msg.entities;\n  if (msg.timeout) {\n      return msg.payload;\n  }\n  if (entities == null) {\n        return entities;\n  }\n  //node.warn('default');\n  //node.warn(entities[entityStr.toLowerCase()] || entities['default']);\n    return (entities[entityStr.toLowerCase()] || entities['default']);\n}\n//\n// Global ID Retrieval Function (v1.1)\n//\nfunction getGlobalID (global_id){\n    //Check if entity_id was passed\n    if (global_id != null && global_id.includes(\".\")) {\n        global_id = global_id.split(\".\")[1];\n    } else {\n        global_id = global_id;\n    }\n    // Return global value\n    return global_id;\n}\n//\n// Global Variable Setter Function (v1.0)\n//\nfunction setGlobalVariable (global_id, value){\n    // Set global value\n    global.set(global_id, value);\n    node.warn('Global Variable ['+ global_id +'] set to '+ value);\n}","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1200,"y":220,"wires":[[]]},{"id":"7c91755d1c80762d","type":"switch","z":"5c17ae8417803497","name":"Entity Type Switch","property":"global_id","propertyType":"msg","rules":[{"t":"cont","v":"timeout","vt":"str"},{"t":"cont","v":"frequency","vt":"str"},{"t":"else"}],"checkall":"false","repair":false,"outputs":3,"x":610,"y":80,"wires":[["3a05381ee4331d5f"],["3a05381ee4331d5f"],["d4d4a0610c74c3b0","f0de75025c9049c4","d01813745291ec33"]]},{"id":"3a05381ee4331d5f","type":"subflow:1671b0eb36e8a5c9","z":"5c17ae8417803497","name":"","x":870,"y":60,"wires":[["d4d4a0610c74c3b0","f0de75025c9049c4","d01813745291ec33"]]},{"id":"d4d4a0610c74c3b0","type":"function","z":"5c17ae8417803497","d":true,"name":"Global Context Entity Mapper (v1.5)","func":"// Global Context Entity Mapper (v1.5)\n// Maps entity state to global variable for automations\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : current entity state value\n// msg.global_id            : Global Context identifier / Entity ID\n// msg.entities [OPTIONAL]  : Key/Value json mapping for input_select entities\n//\n// -*- OUTPUTS -*-\n// msg.payload              : global variable value\n// msg.global_id            : Actual Global Context identifier\n// ******************************************************************\n\n/*** START ***/\nvar entityState = getStateMapping(msg.payload);\n//node.warn('inputSelectEntity: '+ inputSelectEntity);\nvar globalID = getGlobalID(msg.global_id);\nif (entityState != null && globalID) {\n    // Set global variable\n    setGlobalVariable(globalID, entityState);\n    // Return details in msg for further processing if needed\n    msg.payload = entityState;\n    msg.global_id = globalID;\n    // Consider writing another function to determine wheter to clear\n    // the msg object and what items to potentially keep etc.\n    return msg;\n} else {\n    // Error? Log, needs to be fleshed out with proper cause identified\n    node.warn('Invalid/Missing Entity Mapping: ' + msg.payload + ' please ensure mapping is lowercase');\n    return null;\n}\n/*** END ***/\n\n/*** HELPER FUNCTIONS ***/\n\n/**\n* Entity State Mapping Retrieval Function (v1.1) *\n* @param {string} state\n*/\nfunction getStateMapping(state) {\n    var entityMapping = msg.entities;\n    // If timeout value flag is true, ignore mapping\n    if (msg.timeout) {\n        return msg.payload;\n    }\n    // Return state as is if no mapping provided\n    if (entityMapping == null) {\n        return state;\n    }\n    // Otherwise return corresponding mapping for state (lowercase) \n    // or default value if no map found, otherwise null\n    //node.warn('getStateMapping: ' + entities[entityStr.toLowerCase()] || entities['default']);\n    return (entityMapping[state.toLowerCase()] || entityMapping['default'] || null);\n}\n\n/**\n* Global ID Retrieval Function (v1.2) *\n* @param {string} global_id\n*/\nfunction getGlobalID(global_id) {\n    // If an entity_id was passed, remove entity type\n    if (global_id != null && global_id.includes(\".\")) {\n        global_id = global_id.split(\".\")[1];\n    }\n    // Return global ID\n    return global_id;\n}\n\n/**\n* Global Variable Setter Function (v1.0) *\n* @param {string} global_id\n* @param {string} value\n*/\nfunction setGlobalVariable(global_id, value) {\n    // Set global value\n    global.set(global_id, value);\n    node.warn('Global Variable [' + global_id + '] set to ' + value);\n}\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1180,"y":160,"wires":[[]]},{"id":"a5721d738561d2de","type":"function","z":"5c17ae8417803497","d":true,"name":"Global Context Entity Mapper (v1.5b)","func":"// Global Context Entity Mapper (v1.5)\n// Maps entity state to global variable for automations\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : current entity state value\n// msg.global_id            : Global Context identifier / Entity ID\n// msg.entities [OPTIONAL]  : Key/Value json mapping for input_select entities\n//\n// -*- OUTPUTS -*-\n// msg.payload              : global variable value\n// msg.global_id            : Actual Global Context identifier\n// ******************************************************************\n\n/*** START ***/\nvar utils = global.get(\"utils\");\nvar global_id = msg.global_id;\nvar entity_state = getStateMapping(msg.payload);\n\nif (msg.remove_prefix && utils.isEntityID(global_id)) {\n    global_id = global_id.split(\".\")[1];\n}\n\nif (entity_state != null && global_id) {\n    // Set global variable\n    setGlobalVariable(global_id, entity_state);\n    // Return details in msg for further processing if needed\n    msg.payload = entity_state;\n    msg.global_id = global_id;\n    // Consider writing another function to determine wheter to clear\n    // the msg object and what items to potentially keep etc.\n    return msg;\n} else {\n    // Error? Log, needs to be fleshed out with proper cause identified\n    node.warn('Invalid/Missing Entity Mapping: ' + msg.payload + ' please ensure mapping is lowercase');\n    return null;\n}\n/*** END ***/\n\n/*** HELPER FUNCTIONS ***/\n\n/**\n* Entity State Mapping Retrieval Function (v1.1) *\n* @param {string} state\n*/\nfunction getStateMapping(state) {\n    var entityMapping = msg.entities;\n    // If timeout value flag is true, ignore mapping\n    if (msg.timeout) return msg.payload;\n    // Return state as is if no mapping provided\n    if (entityMapping == null) return state;\n    // Otherwise return corresponding mapping for state (lowercase) \n    // or default value if no map found, otherwise null\n    return (entityMapping[state.toLowerCase()] || entityMapping['default'] || null);\n}\n\n/**\n* Check if valid entity ID to retain legacy functionality\n* @param {string} global_id\n*/\nfunction stripDomain(global_id) {\n    if (msg.remove_prefix) {\n\n        // If an entity_id was passed, remove entity type\n        if (utils.isEntityID(global_id)) {\n            global_id = global_id.split(\".\")[1];\n        }\n        \n    }\n    \n    // Return global ID\n    return global_id;\n}\n\n/**\n* Global Variable Setter Function (v1.0) *\n* @param {string} global_id\n* @param {string} value\n*/\nfunction setGlobalVariable(global_id, value) {\n    // Set global value\n    global.set(global_id, value);\n    node.warn('Global Variable [' + global_id + '] set to ' + value);\n}","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1190,"y":340,"wires":[[]]},{"id":"c576d1611d4abedf","type":"function","z":"5c17ae8417803497","d":true,"name":"Global Context Entity Mapper (v1.6)","func":"// Global Context Entity Mapper (v1.6)\n// Maps entity state to global variable for automations\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : current entity state value\n// msg.global_id            : Global Context identifier / Entity ID\n// msg.entities [OPTIONAL]  : Key/Value json mapping for input_select entities\n//\n// -*- OUTPUTS -*-\n// msg.payload              : global variable value\n// msg.global_id            : Actual Global Context identifier\n// ******************************************************************\n\n/*** START ***/\nconst utils = global.get(\"utils\");\nnode.warn(\"WAG1\");\n// Return if no global_id\nif (!msg.global_id) {\n    node.warn(`Missing msg.global_id: ${msg.global_id}`);\n    return null;\n}\n\n// Return if no payload\nif (!msg.payload) {\n    node.warn(`Missing msg.payload: ${msg.payload}`);\n    return null;\n}\n\nvar entityState = getStateMapping(msg.payload);\n//node.warn('inputSelectEntity: '+ inputSelectEntity);\ntry {\n    var globalID = getGlobalID(msg.global_id);\n} catch (error) {\n    node.warn(`Error retrieving global ID: ${error.message}`);\n    return null;\n}\n\nif (entityState != null && globalID) {\n    // Set global variable\n    setGlobalVariable(globalID, entityState);\n    // Return details in msg for further processing if needed\n    msg.payload = entityState;\n    msg.global_id = globalID;\n    // Consider writing another function to determine wheter to clear\n    // the msg object and what items to potentially keep etc.\n    return msg;\n} else {\n    // Error? Log, needs to be fleshed out with proper cause identified\n    node.warn('Invalid/Missing Entity Mapping: ' + msg.payload + ' please ensure mapping is lowercase');\n    return null;\n}\n/*** END ***/\n\n/*** HELPER FUNCTIONS ***/\n\n/**\n* Entity State Mapping Retrieval Function (v1.1) *\n* @param {string} state\n*/\nfunction getStateMapping(state) {\n    var entityMapping = msg.entities;\n    // If timeout value flag is true, ignore mapping\n    if (msg.timeout) {\n        return msg.payload;\n    }\n    // Return state as is if no mapping provided\n    if (entityMapping == null) {\n        return state;\n    }\n    // Otherwise return corresponding mapping for state (lowercase) \n    // or default value if no map found, otherwise null\n    //node.warn('getStateMapping: ' + entities[entityStr.toLowerCase()] || entities['default']);\n    return (entityMapping[state.toLowerCase()] || entityMapping['default'] || null);\n}\n\n/**\n * Global ID Retrieval Function (v1.2)\n * @param {string} global_id\n */\nfunction getGlobalID(global_id) {\n    try {\n        // If an entity_id was passed, remove entity type\n        if (utils.getEntity(global_id)) global_id = global_id.split(\".\")[1];\n\n        // Return global ID\n        return global_id;\n    } catch (error) {\n        // Handle any errors thrown by getEntity\n        return ;\n    }\n}\n\n\n/**\n* Global Variable Setter Function (v1.0) *\n* @param {string} global_id\n* @param {string} value\n*/\nfunction setGlobalVariable(global_id, value) {\n    // Set global value\n    global.set(global_id, value);\n    node.warn('Global Variable [' + global_id + '] set to ' + value);\n}","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1180,"y":400,"wires":[[]]},{"id":"f0de75025c9049c4","type":"function","z":"5c17ae8417803497","d":true,"name":"Global Context Entity Mapper (v1.69)","func":"// Global Context Mapper (v1.8)\n// Maps payload to global context object for use in automations\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : current state\n// msg.global_id            : Global Context identifier / Entity ID\n// msg.entities [OPTIONAL]  : Key/Value json mapping for input_select entities\n//\n// -*- OUTPUTS -*-\n// msg.payload              : global context value\n// ******************************************************************\n\n/*** START ***/\n\n//const utils = global.get(\"utils\");\n//const SOURCE_PATHS_HELPER = \"input_text.repository_paths\";\n\nlet utilsPromise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        const utils = global.get(env.get(\"UTIL\") || \"system.util\");\n        node.warn(env.get(\"UTIL\"));\n        //const STATES = global.get(\"homeassistant.homeAssistant.states\");\n        if (utils) {\n            resolve(utils);\n        } else {\n            reject(new Error(\"utils object not available\"));\n        }\n    }, 5); // 1000 milliseconds = 1 second\n});\n\nutilsPromise\n    .then(utils => {\n        // Proceed with your code using the 'utils' object\n\n        //const PATH_CONTEXT_ID = ;\n        //const PATH = global.get(utils[SOURCE_PATHS_HELPER].state);\n        //const utils = global.get(PATH.UTIL.OBJECT);\n        let status;\n        // Return if no global_id\n        if (!msg.global_id) {\n            status = `Missing msg.global_id: ${msg.global_id}`;\n            node.warn(status);\n            return [null, utils.status(status, { fill: \"red\" })];\n        }\n\n        // Return if no payload\n        if (!utils.exists(msg.payload)) {\n            status = `Missing msg.payload: ${msg.payload}`\n            node.warn(status);\n            return [null, utils.status(status, { fill: \"red\" })];\n        }\n        var entityState = getStateMapping(msg.payload);\n        //node.warn('inputSelectEntity: '+ inputSelectEntity);\n\n        getGlobalID(msg.global_id)\n            .then(global_id => {\n                // This code will execute when the promise is resolved\n\n                if (entityState != null && global_id) {\n                    // Set global variable\n                    setGlobalVariable(global_id, entityState);\n                    // Return details in msg for further processing if needed\n                    msg.payload = entityState;\n                    msg.global_id = global_id;\n                    // Consider writing another function to determine whether to clear\n                    // the msg object and what items to potentially keep etc.\n                    status = `[${global_id}] set to: ${entityState}`;\n                    node.send([msg, utils.status(status)]);\n                } else {\n                    //node.warn(entityState);\n                    //node.warn(msg.entities['default']);\n                    // Error? Log, needs to be fleshed out with proper cause identified\n                    status = 'Invalid/Missing Entity Mapping: ' + msg.payload + ' please ensure mapping is lowercase';\n                    node.warn(status);\n                    node.send([null, utils.status(msg, { fill: \"red\" })]);\n                }\n            })\n            .catch(error => {\n                // This code will execute when the promise is rejected\n                const status = `Error retrieving global ID: ${error.message}`;\n                node.warn(status);\n                node.send([null, utils.status(status, { fill: \"red\" })]);\n            });\n\n        /*** HELPER FUNCTIONS ***/\n\n        /**\n        * Entity State Mapping Retrieval Function (v1.1) *\n        * @param {string} state\n        */\n        function getStateMapping(state) {\n            var entityMapping = msg.entities;\n            // If timeout value flag is true, ignore mapping\n            if (msg.timeout) {\n                return msg.payload;\n            }\n            // Return state as is if no mapping provided\n            if (entityMapping == null) {\n                return state;\n            }\n            // Otherwise return corresponding mapping for state (lowercase) \n            // or default value if no map found, otherwise null\n            //node.warn('getStateMapping: ' + entities[entityStr.toLowerCase()] || entities['default']);\n            //return (entityMapping[state.toLowerCase()] || entityMapping['default'] || null);\n            return entityMapping[state.toLowerCase()] !== undefined ? entityMapping[state.toLowerCase()] :\n                entityMapping['default'] !== undefined ? entityMapping['default'] :\n                    null;\n\n        }\n\n        function getGlobalID(global_id) {\n            const status = `Waiting for entities object...`;\n            node.status({ fill: \"yellow\", shape: \"dot\", text: status });\n            node.send([null, utils.status(status, { fill: \"yellow\" })]);\n            return utils.getEntity(global_id)\n                .then(entity => {\n                    // If an entity_id was passed, remove entity type\n                    if (entity) global_id = global_id.split(\".\")[1];\n\n                    // Return global ID\n                    return global_id;\n                })\n                .catch(error => {\n                    // Handle any errors thrown by getEntity\n                    const status = `[ERROR]: ${error.message}`;\n                    node.warn(status);\n                    node.status({ fill: \"red\", shape: \"dot\", text: status });\n                    return null;\n                });\n        }\n\n        /**\n        * Global Variable Setter Function (v1.0) *\n        * @param {string} global_id\n        * @param {string} value\n        */\n        function setGlobalVariable(global_id, value) {\n            // Set global value\n            global.set(global_id, value);\n            const status = `Global Context [${global_id}] set to: ${value}`;;\n            //node.warn(status);\n            node.status(utils.status(status, { fill: \"green\" }).payload);\n        }\n\n    })\n    .catch(error => {\n        node.warn(\"[ERROR]: \" + error.message);\n    });\n\n/*** END ***/","outputs":2,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1190,"y":540,"wires":[[],[]]},{"id":"28f9d89a929c929b","type":"change","z":"5c17ae8417803497","name":"Set global_id from env","rules":[{"t":"set","p":"global_id","pt":"msg","to":"GLOBAL_ID","tot":"env"}],"action":"","property":"","from":"","to":"","reg":false,"x":380,"y":60,"wires":[["7c91755d1c80762d"]]},{"id":"525d918b5abc8b1f","type":"switch","z":"5c17ae8417803497","name":"env.GLOBAL_ID passed?","property":"GLOBAL_ID","propertyType":"env","rules":[{"t":"nempty"},{"t":"empty"}],"checkall":"true","repair":false,"outputs":2,"x":130,"y":80,"wires":[["28f9d89a929c929b"],["7c91755d1c80762d"]]},{"id":"d01813745291ec33","type":"function","z":"5c17ae8417803497","name":"Global Context Entity Mapper (v2)","func":"// Global Context Mapper (v2)\n// Maps payload to global context object for use in automations\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : current state\n// msg.global_id            : Global Context identifier / Entity ID\n// msg.entities [OPTIONAL]  : Key/Value json mapping for input_select entities\n//\n// -*- OUTPUTS -*-\n// msg.payload              : global context value\n// ******************************************************************\n\n/*** START ***/\n//const utils = global.get(env.get(\"UTIL\") || \"util\");\nconst utils = context.global[env.get(\"MODULE_ID\")].util.common;\n\nif (!utils) {\n    // Utils module not loaded\n}\n\nlet status;\n// Return if no global_id\nif (!msg.global_id) {\n    status = `Missing msg.global_id: ${msg.global_id}`;\n    node.warn(status);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\n\n// Return if no payload\nif (!utils.exists(msg.payload)) {\n    status = `Missing msg.payload: ${msg.payload}`\n    node.warn(status);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\nvar state = getStateMapping(msg.payload);\n//node.warn('inputSelectEntity: '+ inputSelectEntity);\n\nif (!utils.exists(state)) {\n    // Error? Log, needs to be fleshed out with proper cause identified\n    status = `Invalid/Missing Entity State/Mapping: [${msg.payload}:${state}]. Please ensure mapping is lowercase.`;\n    node.warn(status);\n    return [null, utils.status(msg, { fill: \"red\" })];\n}\n\nconst Entities = context.global.system.domain.models.Entities;\nconst entity = Entities.getEntity(msg.global_id);\n\nif (entity) msg.global_id = msg.global_id.split(\".\")[1];\n\nglobal.set(msg.global_id, state);\n\nstatus = `[${msg.global_id}] set to: ${state}`;\nnode.status(utils.status(status, { fill: \"green\" }).payload);\n\n// Return details in msg for further processing if needed\nmsg.payload = state;\n\nreturn [msg, utils.status(status)];\n\n/*** END ***/\n\n\n/*** HELPER FUNCTIONS ***/\n\n/**\n* Entity State Mapping Retrieval Function (v1.1) *\n* @param {string} state\n*/\nfunction getStateMapping(state) {\n    var entityMapping = msg.entities;\n    // If timeout value flag is true, ignore mapping\n    if (msg.timeout) {\n        return state;\n    }\n    // Return state as is if no mapping provided\n    if (!entityMapping) {\n        return state;\n    }\n    // Otherwise return corresponding mapping for state (lowercase) \n    // or default value if no map found, otherwise null\n    //node.warn('getStateMapping: ' + entities[entityStr.toLowerCase()] || entities['default']);\n    //return (entityMapping[state.toLowerCase()] || entityMapping['default'] || null);\n    return entityMapping[state.toLowerCase()] !== undefined ? entityMapping[state.toLowerCase()] :\n        entityMapping['default'] !== undefined ? entityMapping['default'] :\n            null;\n\n}","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1180,"y":100,"wires":[[],[]]},{"id":"0ef5f7b2825dd360","type":"function","z":"5c17ae8417803497","name":"Global Context Entity Mapper (v1.7)","func":"// Global Context Mapper (v1.7)\n// Maps payload to global context object for use in automations\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload              : current state\n// msg.global_id            : Global Context identifier / Entity ID\n// msg.entities [OPTIONAL]  : Key/Value json mapping for input_select entities\n//\n// -*- OUTPUTS -*-\n// msg.payload              : global context value\n// ******************************************************************\n\n/*** START ***/\n\n//const utils = global.get(\"utils\");\n\nlet utilsPromise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        const utils = global.get(\"utils\");\n        if (utils) {\n            resolve(utils);\n        } else {\n            reject(new Error(\"utils object not available\"));\n        }\n    }, 1000); // 1000 milliseconds = 1 second\n});\n\nutilsPromise\n    .then(utils => {\n        // Proceed with your code using the 'utils' object\n\n        let status;\n        // Return if no global_id\n        if (!msg.global_id) {\n            status = `Missing msg.global_id: ${msg.global_id}`;\n            node.warn(status);\n            return [null, utils.status(status, { fill: \"red\" })];\n        }\n\n        // Return if no payload\n        if (!utils.exists(msg.payload)) {\n            status = `Missing msg.payload: ${msg.payload}`\n            node.warn(status);\n            return [null, utils.status(status, { fill: \"red\" })];\n        }\n        var entityState = getStateMapping(msg.payload);\n        //node.warn('inputSelectEntity: '+ inputSelectEntity);\n\n        getGlobalID(msg.global_id)\n            .then(global_id => {\n                // This code will execute when the promise is resolved\n\n                if (entityState != null && global_id) {\n                    // Set global variable\n                    setGlobalVariable(global_id, entityState);\n                    // Return details in msg for further processing if needed\n                    msg.payload = entityState;\n                    msg.global_id = global_id;\n                    // Consider writing another function to determine whether to clear\n                    // the msg object and what items to potentially keep etc.\n                    status = `[${global_id}] set to: ${entityState}`;\n                    node.send([msg, utils.status(status)]);\n                } else {\n                    node.warn(entityState);\n                    node.warn(msg.entities['default']);\n                    // Error? Log, needs to be fleshed out with proper cause identified\n                    status = 'Invalid/Missing Entity Mapping: ' + msg.payload + ' please ensure mapping is lowercase';\n                    node.warn(status);\n                    node.send([null, utils.status(msg, { fill: \"red\" })]);\n                }\n            })\n            .catch(error => {\n                // This code will execute when the promise is rejected\n                const status = `Error retrieving global ID: ${error.message}`;\n                node.warn(status);\n                node.send([null, utils.status(status, { fill: \"red\" })]);\n            });\n\n        /*** HELPER FUNCTIONS ***/\n\n        /**\n        * Entity State Mapping Retrieval Function (v1.1) *\n        * @param {string} state\n        */\n        function getStateMapping(state) {\n            var entityMapping = msg.entities;\n            // If timeout value flag is true, ignore mapping\n            if (msg.timeout) {\n                return msg.payload;\n            }\n            // Return state as is if no mapping provided\n            if (entityMapping == null) {\n                return state;\n            }\n            // Otherwise return corresponding mapping for state (lowercase) \n            // or default value if no map found, otherwise null\n            //node.warn('getStateMapping: ' + entities[entityStr.toLowerCase()] || entities['default']);\n            //return (entityMapping[state.toLowerCase()] || entityMapping['default'] || null);\n            return entityMapping[state.toLowerCase()] !== undefined ? entityMapping[state.toLowerCase()] :\n                entityMapping['default'] !== undefined ? entityMapping['default'] :\n                    null;\n\n        }\n\n        function getGlobalID(global_id) {\n            const status = `Waiting for entities object...`;\n            node.status({ fill: \"yellow\", shape: \"dot\", text: status });\n            node.send([null, utils.status(status, { fill: \"yellow\" })]);\n            return utils.getEntity(global_id)\n                .then(entity => {\n                    // If an entity_id was passed, remove entity type\n                    if (entity) global_id = global_id.split(\".\")[1];\n\n                    // Return global ID\n                    return global_id;\n                })\n                .catch(error => {\n                    // Handle any errors thrown by getEntity\n                    const status = `[ERROR]: ${error.message}`;\n                    node.warn(status);\n                    node.status({ fill: \"red\", shape: \"dot\", text: status });\n                    return null;\n                });\n        }\n\n        /**\n        * Global Variable Setter Function (v1.0) *\n        * @param {string} global_id\n        * @param {string} value\n        */\n        function setGlobalVariable(global_id, value) {\n            // Set global value\n            global.set(global_id, value);\n            const status = `Global Context [${global_id}] set to: ${value}`;;\n            //node.warn(status);\n            node.status(utils.status(status, { fill: \"green\" }).payload);\n        }\n\n    })\n    .catch(error => {\n        node.warn(\"[ERROR]: \" + error.message);\n    });\n\n/*** END ***/","outputs":2,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1180,"y":500,"wires":[[],[]]},{"id":"ac18d08ecf3b428c","type":"subflow","name":"Occupancy Mode Updater","info":"","category":"","in":[{"x":0,"y":80,"wires":[{"id":"9b418cd91f2b0e34"},{"id":"82de18d878475171"}]}],"out":[{"x":400,"y":40,"wires":[{"id":"9b418cd91f2b0e34","port":0},{"id":"82de18d878475171","port":0}]}],"env":[{"name":"ENTITY_ID","type":"str","value":"input_select.occupancy_mode"}],"meta":{},"color":"#DDAA99","status":{"x":400,"y":120,"wires":[{"id":"9b418cd91f2b0e34","port":1},{"id":"82de18d878475171","port":1}]}},{"id":"9b418cd91f2b0e34","type":"function","z":"ac18d08ecf3b428c","d":true,"name":"Determine Occupancy Mode 1.1b","func":"// Determine Occupancy Mode (v1.1)\n// Determine Occupancy Mode\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload.occupancy    : Custom occupancy object global_id\n// msg.payload.presence     : Custom presence object global_id\n//\n// -*- OUTPUTS -*-\n// msg.payload              : Current occupancy mode\n// ******************************************************************\n\n/*** START ***/\nconst utils = global.get(\"utils\");\n\n// Define occupancy modes\nconst OCCUPANCY_MODES = {\n    HOME: 'HOME',\n    AWAY: 'AWAY',\n    SLEEP: 'SLEEP',\n    GUEST: 'GUEST',\n    UNKNOWN: 'UNKNOWN',\n    ROGUE: 'PROTOCOL_1'\n};\n\nconst DATA_PATHS = {\n    USER_PRESENT: 'user_present',   // Boolean\n    OCCUPIED: 'occupied',           // Object\n    STATE: 'state',                 // Boolean\n    SLEEP_AREA: 'bedroom',          // String (Area ID)\n    OCCUPANCY_MODE: 'mode',         // String\n    AREAS: 'areas',                 // String (Area ID)\n    AREA_ID: 'area_id'              //\n};\n\n// Define rules for each occupancy mode\nconst occupancyRules = {\n    [OCCUPANCY_MODES.HOME]: (occupancy, presence) => {\n\n        // Return if guest mode enabled\n        if (isGuestModeActive(occupancy)) return false;\n\n        // Base logic to determine if the home is occupied based on occupancy and presence\n        return (\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] === true ||    // Occupied\n            presence[DATA_PATHS.USER_PRESENT] === true                      // User(s) present\n        );\n    },\n    [OCCUPANCY_MODES.AWAY]: (occupancy, presence) => {\n\n        // Return if guest mode enabled\n        if (isGuestModeActive(occupancy)) return false;\n\n        // Base logic to determine if the home is empty based on occupancy and presence\n        return (\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] === false &&   // Occupied\n            presence[DATA_PATHS.USER_PRESENT] === false                     //User(s) not present\n        );\n    },\n    [OCCUPANCY_MODES.SLEEP]: (occupancy, presence) => {\n\n        if (isGuestModeActive(occupancy)) return false;\n\n        // Base logic to determine if the home is in sleep mode based on occupancy and presence\n        return (\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.AREA_ID] == DATA_PATHS.SLEEP_AREA &&  // Last occupied area = sleep area\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] == false &&                    // Unoccupied (inactivity) \n            presence[DATA_PATHS.USER_PRESENT] == true                                       // User(s) present\n        );\n    },\n    [OCCUPANCY_MODES.GUEST]: (occupancy, presence) => {\n\n        // Base logic to determine if there are guests based on presence information\n        return isGuestModeActive(occupancy);\n    }\n};\n\n// Determine Occupancy Mode\nlet status;\n\n// Error if missing data\nif (!msg.payload.occupancy) {\n    status = `Missing msg.payload.occupancy property: ${msg.payload.occupancy}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\nif (!msg.payload.presence) {\n    status = `Missing msg.payload.presence property: ${msg.payload.presence}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\n\n//const occupancy_info = global.get(msg.payload.occupancy);\n\n// Finish this, I want to wait for the global to become available (or to timeout) then proceed\nlet occupancy_info;\nlet presence_info;\n\n// Wait for occupancy_info\ngetGlobal(msg.payload.occupancy)\n    .then(data => {\n        // This code will execute when the promise is resolved\n        if (data) {\n            // Set occupancy_info\n            occupancy_info = global.get(msg.payload.occupancy);//data;\n            continueExecution();\n        }\n        else {\n            const status = `Missing msg.payload.occupancy property: ${msg.payload.occupancy} | ${occupancy_info}`;\n            node.status(utils.status(status, { fill: \"red\" }).payload);\n            node.send([null, utils.status(status, { fill: \"red\" })]);\n        }\n    })\n    .catch(error => {\n        // This code will execute when the promise is rejected\n        const status = `Error retrieving occupancy context: ${error.message}`;\n        node.warn(status);\n        node.send([null, utils.status(status, { fill: \"red\" })]);\n    });\n\n// Function to continue execution after occupancy_info is retrieved\nfunction continueExecution() {\n    // Wait for presence_info\n    getGlobal(msg.payload.presence)\n        .then(data => {\n            // This code will execute when the promise is resolved\n            if (data) {\n                // Set presence_info\n                presence_info = global.get(msg.payload.presence);//data;\n                proceedWithLogic();\n            }\n            else {\n                const status = `Missing msg.payload.presence property: ${msg.payload.presence} | ${presence_info}`;\n                node.status(utils.status(status, { fill: \"red\" }).payload);\n                node.send([null, utils.status(status, { fill: \"red\" })]);\n            }\n        })\n        .catch(error => {\n            // This code will execute when the promise is rejected\n            const status = `Error retrieving presence context: ${error.message}`;\n            node.warn(status);\n            node.send([null, utils.status(status, { fill: \"red\" })]);\n        });\n}\n\n// Function to proceed with the logic after both occupancy_info and presence_info are retrieved\nfunction proceedWithLogic() {\n    // Clean up Global IDs\n    delete msg.payload.occupancy;\n    delete msg.payload.presence;\n\n    // Error if missing data\n    if (!occupancy_info) {\n        const status = `Missing msg.payload.occupancy property: ${msg.payload.occupancy} | ${occupancy_info}`;\n        node.status(utils.status(status, { fill: \"red\" }).payload);\n        node.send([null, utils.status(status, { fill: \"red\" })]);\n        return;\n    }\n    if (!presence_info) {\n        const status = `Missing msg.payload.presence property: ${msg.payload.presence} | ${presence_info}`;\n        node.status(utils.status(status, { fill: \"red\" }).payload);\n        node.send([null, utils.status(status, { fill: \"red\" })]);\n        return;\n    }\n\n    // Occupancy mode calculation and status update\n    occupancy_info[DATA_PATHS.OCCUPANCY_MODE] = msg.payload.state || occupancy_info[DATA_PATHS.OCCUPANCY_MODE] || OCCUPANCY_MODES.UNKNOWN;\n    const occupancy_mode = determineOccupancyMode(occupancy_info, presence_info);\n    msg.payload = occupancy_mode;\n    return [msg, utils.status(occupancy_mode)];\n}\n\n/*** END ***/\n\n/*** HELPERS ***/\n\n// Function to determine the current occupancy mode\nfunction determineOccupancyMode(occupancy, presence) {\n    for (const mode in occupancyRules) {\n        if (occupancyRules[mode](occupancy, presence)) {\n            return mode;\n        }\n    }\n    // Default to UNKNOWN mode if no other mode matches\n    return OCCUPANCY_MODES.UNKNOWN;\n}\n\nfunction isGuestModeActive(occupancy) {\n    return occupancy[DATA_PATHS.OCCUPANCY_MODE] === OCCUPANCY_MODES.GUEST;\n}\n\n// Not sure if any changes needed here\nfunction getGlobal(global_id, timeout = 15000) {\n    return utils.waitForGlobalContext(global_id, timeout)\n        .then(data => {\n            if (data) return data;\n        })\n        .catch(error => {\n            // Handle any errors thrown by waitForGlobalContext\n            const status = `[ERROR]: ${error.message}`;\n            node.warn(status);\n            //node.status({ fill: \"red\", shape: \"dot\", text: status });\n            node.send([null, null, utils.status(status, { fill: \"red\" })]);\n            return null;\n        });\n}","outputs":2,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is started.\nnode.status({ fill: \"yellow\", shape: \"dot\", text: \"Starting\" });","finalize":"","libs":[],"x":220,"y":220,"wires":[[],[]]},{"id":"82de18d878475171","type":"function","z":"ac18d08ecf3b428c","name":"Occupancy Mode Updater","func":"// Occupancy Mode Updater\n// Determine Occupancy Mode\n// ******************************************************************\n// -*- INPUTS -*-\n// env.ENTITY_ID            : Occupancy Mode Entity ID\n// msg.payload.mode         : Current Occupancy Mode\n//\n// -*- OUTPUTS -*-\n// msg.payload              : Occupancy Mode\n// msg.entity_id            : Occupancy Mode Entity ID\n// ******************************************************************\n\n/*** START ***/\nconst repository = context.global[env.get(\"MODULE_ID\")];\nconst utils = repository.util.common;\nconst OccupancyService = repository.domain.services.OccupancyService;\nconst PresenceService = repository.domain.services.PresenceService;\nconst OCCUPCANY_MODE_ENTITY_ID = msg.entity_id = env.get(\"ENTITY_ID\") || \"input_select.system_occupancy_mode\";\n\n// Define occupancy modes\nconst OCCUPANCY_MODES = {\n    HOME: 'HOME',\n    AWAY: 'AWAY',\n    SLEEP: 'SLEEP',\n    GUEST: 'GUEST',\n    UNKNOWN: 'UNKNOWN',\n    ROGUE: 'PROTOCOL_1'\n};\n\nconst MATCH = {\n    ENTRY_EXIT_AREA: 'kitchen',     // String (Area ID)\n    SLEEP_AREA: 'bedroom'           // String (Area ID)\n};\n\n// Define rules for each occupancy mode\nconst occupancyRules = {\n    [OCCUPANCY_MODES.HOME]: (current_occupancy_mode) => {\n        // Return if guest mode enabled\n        if (guestModeConditionsMet(current_occupancy_mode)) return false;\n\n        // Base logic to determine if the home is occupied based on occupancy and presence\n        return homeModeConditionsMet();\n    },\n    [OCCUPANCY_MODES.AWAY]: (current_occupancy_mode) => {\n\n        // Return if guest mode enabled\n        if (guestModeConditionsMet(current_occupancy_mode)) return false;\n\n        // Base logic to determine if the home is empty based on occupancy and presence\n        // todo - and last occupied area is entry_exit area? To detect guests/intruders\n        return awayModeConditionsMet();\n    },\n    [OCCUPANCY_MODES.SLEEP]: (current_occupancy_mode) => {\n\n        // Return if guest mode enabled\n        if (guestModeConditionsMet(current_occupancy_mode)) return false;\n\n        // Base logic to determine if the home is in sleep mode based on occupancy and presence\n        return sleepModeConditionsMet();\n    },\n    [OCCUPANCY_MODES.GUEST]: (current_occupancy_mode) => {\n\n        // Base logic to determine if there are guests based on occupancy information\n        return guestModeConditionsMet(current_occupancy_mode);\n    }\n};\n\n// Determine Occupancy Mode\nlet status;\n\n// Error if missing service data\nif (!OccupancyService) {\n    status = `Missing OccupancyService object: ${OccupancyService}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\nif (!PresenceService) {\n    status = `Missing PresenceService object: ${PresenceService}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\n\nlet current_occupancy_mode = utils.exists(msg.payload) ? msg.payload.mode : null;\ncurrent_occupancy_mode = current_occupancy_mode ? current_occupancy_mode : global.get(`homeassistant.homeAssistant.states['${OCCUPCANY_MODE_ENTITY_ID}']`);\nif (typeof current_occupancy_mode === \"object\" && utils.exists(current_occupancy_mode.state)) current_occupancy_mode = current_occupancy_mode.state;\n\nOccupancyService.setMode(current_occupancy_mode || OccupancyService.getMode() || OCCUPANCY_MODES.UNKNOWN);\nconst occupancy_mode = determineOccupancyMode(current_occupancy_mode);\nnode.status(utils.status(occupancy_mode).payload);\n\nmsg.payload = occupancy_mode;\nreturn [msg, utils.status(occupancy_mode)];\n\n/*** END ***/\n\n/*** HELPERS ***/\n\n// Function to determine the current occupancy mode\nfunction determineOccupancyMode(current_occupancy_mode) {\n    for (const mode in occupancyRules) {\n        if (occupancyRules[mode](current_occupancy_mode)) return mode;\n    }\n    // Default to UNKNOWN mode if no other mode matches\n    return OCCUPANCY_MODES.UNKNOWN;\n}\n\nfunction homeModeConditionsMet() {\n    return (\n        OccupancyService.isOccupied() === true ||                           // Occupied or... \n        (\n            PresenceService.isPresent() === true &&                         // User(s) present and\n            OccupancyService.getOccupancy().area_id !== MATCH.SLEEP_AREA    // Last occupied area != sleep area\n        )\n    );\n}\n\nfunction awayModeConditionsMet() {\n    return (\n        !OccupancyService.isOccupied() && !PresenceService.isPresent()      // Unoccupied and no User(s) present\n    );\n}\n\nfunction guestModeConditionsMet(current_occupancy_mode) {\n    // Guest mode manually enabled\n    return (\n        current_occupancy_mode === OCCUPANCY_MODES.GUEST ||                 // Guest mode manually triggered\n        OccupancyService.getMode() === OCCUPANCY_MODES.GUEST                // or already active\n    );\n}\n\nfunction sleepModeConditionsMet() {\n    return (\n        OccupancyService.getOccupancy().area_id === MATCH.SLEEP_AREA &&     // Last occupied area = sleep area\n        !OccupancyService.isOccupied() &&                                   // Unoccupied (inactivity) \n        PresenceService.isPresent()                                         // User(s) present                            \n    );\n}","outputs":2,"timeout":"","noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is started.\nnode.status({ fill: \"yellow\", shape: \"dot\", text: \"Starting\" });","finalize":"","libs":[],"x":190,"y":80,"wires":[[],[]]},{"id":"811624ec95867b61","type":"function","z":"ac18d08ecf3b428c","d":true,"name":"Determine Occupancy Mode 1.0","func":"// Determine Occupancy Mode (v1.1)\n// Determine Occupancy Mode\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload.occupancy    : Custom occupancy object global_id\n// msg.payload.presence     : Custom presence object global_id\n//\n// -*- OUTPUTS -*-\n// msg.payload              : Current occupancy mode\n// ******************************************************************\n\n/*** START ***/\nconst utils = global.get(\"utils\");\n\n// Define occupancy modes\nconst OCCUPANCY_MODES = {\n    HOME: 'HOME',\n    AWAY: 'AWAY',\n    SLEEP: 'SLEEP',\n    GUEST: 'GUEST',\n    UNKNOWN: 'UNKNOWN',\n    ROGUE:'PROTOCOL_1'\n};\n\nconst DATA_PATHS = {\n    USER_PRESENT: 'user_present',   // Boolean\n    OCCUPIED: 'occupied',           // Object\n    STATE: 'state',                 // Boolean\n    SLEEP_AREA: 'bedroom',          // String (Area ID)\n    OCCUPANCY_MODE: 'mode',         // String\n    AREAS: 'areas',                 // String (Area ID)\n    AREA_ID: 'area_id'              //\n};\n\n// Define rules for each occupancy mode\nconst occupancyRules = {\n    [OCCUPANCY_MODES.HOME]: (occupancy, presence) => {\n        \n        // Return if guest mode enabled\n        if (isGuestModeActive(occupancy)) return false;\n\n        // Base logic to determine if the home is occupied based on occupancy and presence\n        return (\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] === true ||    // Occupied\n            presence[DATA_PATHS.USER_PRESENT] === true                      // User(s) present\n            );\n    },\n    [OCCUPANCY_MODES.AWAY]: (occupancy, presence) => {\n        \n        // Return if guest mode enabled\n        if (isGuestModeActive(occupancy)) return false;\n\n        // Base logic to determine if the home is empty based on occupancy and presence\n        return (\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] === false &&   // Occupied\n            presence[DATA_PATHS.USER_PRESENT] === false                     //User(s) not present\n            );\n    },\n    [OCCUPANCY_MODES.SLEEP]: (occupancy, presence) => {\n\n        if (isGuestModeActive(occupancy)) return false;\n        \n        // Base logic to determine if the home is in sleep mode based on occupancy and presence\n        return (\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.AREA_ID] == DATA_PATHS.SLEEP_AREA &&  // Last occupied area = sleep area\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] == false &&                    // Unoccupied (inactivity) \n            presence[DATA_PATHS.USER_PRESENT] == true                                       // User(s) present\n        );\n    },\n    [OCCUPANCY_MODES.GUEST]: (occupancy, presence) => {\n\n        // Base logic to determine if there are guests based on presence information\n        return isGuestModeActive(occupancy);\n    }\n};\n\n// Determine Occupancy Mode\nlet status;\n\n// Error if missing data\nif (!msg.payload.occupancy) {\n    status = `Missing msg.payload.occupancy property: ${msg.payload.occupancy}`;\n    node.status(utils.status(status, {fill: \"red\"}).payload);\n    return [null, utils.status(status, {fill: \"red\"})];\n}\nif (!msg.payload.presence) {\n    status = `Missing msg.payload.presence property: ${msg.payload.presence}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\n\nconst occupancy_info = global.get(msg.payload.occupancy);\nconst presence_info = global.get(msg.payload.presence);\n\n// Clean up Global ID's\ndelete msg.payload.occupancy;\ndelete msg.payload.presence;\n\n// Error if missing data\nif (!occupancy_info) { \n    status = `Missing msg.payload.occupancy property: ${msg.payload.occupancy} | ${occupancy_info}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\nif (!presence_info) {\n    status = `Missing msg.payload.presence property: ${msg.payload.presence} | ${presence_info}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\n\n/*if (!msg.payload.state) {\n    status.fill = \"red\";\n    status.text = `Missing msg.payload.state property: ${msg.payload.state} | ${msg.payload.state}`;\n    node.status(status);\n    return [null, utils.status(status)];\n}*/\n\noccupancy_info[DATA_PATHS.OCCUPANCY_MODE] = msg.payload.state || occupancy_info[DATA_PATHS.OCCUPANCY_MODE] || OCCUPANCY_MODES.UNKNOWN;\n\nconst occupancy_mode = determineOccupancyMode(occupancy_info, presence_info);\nnode.status(utils.status(occupancy_mode).payload);\n\nmsg.payload = occupancy_mode;\nreturn [msg, utils.status(occupancy_mode)];\n\n/*** END ***/\n\n/*** HELPERS ***/\n\n// Function to determine the current occupancy mode\nfunction determineOccupancyMode(occupancy, presence) {\n    for (const mode in occupancyRules) {\n        if (occupancyRules[mode](occupancy, presence)) {\n            return mode;\n        }\n    }\n    // Default to UNKNOWN mode if no other mode matches\n    return OCCUPANCY_MODES.UNKNOWN;\n}\n\nfunction isGuestModeActive(occupancy) {\n    return occupancy[DATA_PATHS.OCCUPANCY_MODE] === OCCUPANCY_MODES.GUEST;\n}\n\n/*getDelay(msg.delay, msg.timeout)\n    .then(delay => {\n        // This code will execute when the promise is resolved\n        node.warn(delay);\n        if (delay) {\n            // Set msg.delay\n            msg.delay = delay;\n            // Return details in msg for further processing if needed\n            node.send([msg, null, utils.status(`${msg.delay} milliseconds`)]);\n        }\n        else {\n            node.send([null, null, utils.status(`Missing msg.delay | env.POLL_RATE: ${msg.delay} | ${pollRate}`, { fill: \"orange\" })]);\n        }\n    })\n    .catch(error => {\n        // This code will execute when the promise is rejected\n        const status = `Error retrieving delay context: ${error.message}`;\n        node.warn(status);\n        node.send([null, null, utils.status(status, { fill: \"red\" })]);\n    });\n\nnode.send([null, msg, utils.status(`Waiting for ${msg.delay}...`, { fill: \"yellow\" })]);\n\nfunction getDelay(global_id, timeout) {\n    return utils.waitForGlobalContext(global_id, timeout)\n        .then(delay => {\n            if (delay) return delay;\n        })\n        .catch(error => {\n            // Handle any errors thrown by waitForGlobalContext\n            const status = `[ERROR]: ${error.message}`;\n            node.warn(status);\n            //node.status({ fill: \"red\", shape: \"dot\", text: status });\n            node.send([null, null, utils.status(status, { fill: \"red\" })]);\n            return null;\n        });\n}*/","outputs":2,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is started.\nnode.status({ fill: \"yellow\", shape: \"dot\", text: \"Starting\" });","finalize":"","libs":[],"x":210,"y":160,"wires":[[],[]]},{"id":"3bea60dad40c54fd","type":"function","z":"ac18d08ecf3b428c","name":"Determine Occupancy Mode 2","func":"// Determine Occupancy Mode (v2)\n// Determine Occupancy Mode\n// ******************************************************************\n// -*- INPUTS -*-\n// msg.payload.occupancy    : Custom occupancy object global_id\n// msg.payload.presence     : Custom presence object global_id\n//\n// -*- OUTPUTS -*-\n// msg.payload              : Current occupancy mode\n// ******************************************************************\n\n/*** START ***/\nconst utils = global.get(\"utils\");\n\n// Define occupancy modes\nconst OCCUPANCY_MODES = {\n    HOME: 'HOME',\n    AWAY: 'AWAY',\n    SLEEP: 'SLEEP',\n    GUEST: 'GUEST',\n    UNKNOWN: 'UNKNOWN',\n    ROGUE:'PROTOCOL_1'\n};\n\nconst DATA_PATHS = {\n    USER_PRESENT: 'user_present',   // Boolean\n    OCCUPIED: 'occupied',           // Object\n    STATE: 'state',                 // Boolean\n    SLEEP_AREA: 'bedroom',          // String (Area ID)\n    OCCUPANCY_MODE: 'mode',         // String\n    AREAS: 'areas',                 // String (Area ID)\n    AREA_ID: 'area_id'              //\n};\n\n// Define rules for each occupancy mode\nconst occupancyRules = {\n    [OCCUPANCY_MODES.HOME]: (occupancy, presence) => {\n        //node.warn(`isSleepModeActive: ${isSleepModeActive(occupancy, presence)}`);\n        // Return if guest/sleep mode enabled\n        if (isGuestModeActive(occupancy) || isSleepModeActive(occupancy, presence)) return false;\n\n        // Base logic to determine if the home is occupied based on occupancy and presence\n        return (\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] === true ||    // Occupied\n            presence[DATA_PATHS.USER_PRESENT] === true                      // User(s) present\n            );\n    },\n    [OCCUPANCY_MODES.AWAY]: (occupancy, presence) => {\n        \n        // Return if guest/sleep mode enabled\n        if (isGuestModeActive(occupancy) || isSleepModeActive(occupancy, presence)) return false;\n\n        // Base logic to determine if the home is empty based on occupancy and presence\n        return (\n            occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] === false &&   // Occupied\n            presence[DATA_PATHS.USER_PRESENT] === false                     //User(s) not present\n            );\n    },\n    [OCCUPANCY_MODES.SLEEP]: (occupancy, presence) => {\n\n        if (isGuestModeActive(occupancy)) return false;\n        \n        // Base logic to determine if the home is in sleep mode based on occupancy and presence\n        return isSleepModeActive(occupancy, presence);\n            },\n    [OCCUPANCY_MODES.GUEST]: (occupancy, presence) => {\n\n        // Base logic to determine if there are guests based on occupancy information\n        return isGuestModeActive(occupancy);\n    }\n};\n\n// Determine Occupancy Mode\nlet status;\n\n// Error if missing data\nif (!msg.payload.occupancy) {\n    status = `Missing msg.payload.occupancy property: ${msg.payload.occupancy}`;\n    node.status(utils.status(status, {fill: \"red\"}).payload);\n    return [null, utils.status(status, {fill: \"red\"})];\n}\nif (!msg.payload.presence) {\n    status = `Missing msg.payload.presence property: ${msg.payload.presence}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\n//node.warn(msg.payload.occupancy);\nconst occupancy_info = global.get(msg.payload.occupancy);\nconst presence_info = global.get(msg.payload.presence);\n//node.warn(global.get(\"system.occupancy\"));\n//node.warn(occupancy_info);\n// Clean up Global ID's\ndelete msg.payload.occupancy;\ndelete msg.payload.presence;\n//node.warn(occupancy_info);\n// Error if missing data\nif (!occupancy_info) { \n    status = `Missing occupancy object: ${msg.payload.occupancy} | ${occupancy_info}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\nif (!presence_info) {\n    status = `Missing presence object: ${msg.payload.presence} | ${presence_info}`;\n    node.status(utils.status(status, { fill: \"red\" }).payload);\n    return [null, utils.status(status, { fill: \"red\" })];\n}\n\n/*if (!msg.payload.state) {\n    status.fill = \"red\";\n    status.text = `Missing msg.payload.state property: ${msg.payload.state} | ${msg.payload.state}`;\n    node.status(status);\n    return [null, utils.status(status)];\n}*/\n\noccupancy_info[DATA_PATHS.OCCUPANCY_MODE] = msg.payload.state || occupancy_info[DATA_PATHS.OCCUPANCY_MODE] || OCCUPANCY_MODES.UNKNOWN;\n\nconst occupancy_mode = determineOccupancyMode(occupancy_info, presence_info);\nnode.status(utils.status(occupancy_mode).payload);\n\nmsg.payload = occupancy_mode;\nreturn [msg, utils.status(occupancy_mode)];\n\n/*** END ***/\n\n/*** HELPERS ***/\n\n// Function to determine the current occupancy mode\nfunction determineOccupancyMode(occupancy, presence) {\n    for (const mode in occupancyRules) {\n        if (occupancyRules[mode](occupancy, presence)) {\n            return mode;\n        }\n    }\n    // Default to UNKNOWN mode if no other mode matches\n    return OCCUPANCY_MODES.UNKNOWN;\n}\n\nfunction isGuestModeActive(occupancy) {\n    return occupancy[DATA_PATHS.OCCUPANCY_MODE] === OCCUPANCY_MODES.GUEST;\n}\n\nfunction isSleepModeActive(occupancy, presence) {\n    //node.warn(`sleep area = las occupied area?: ${occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.AREA_ID] == DATA_PATHS.SLEEP_AREA}`);\n    //node.warn(`occupied = false?: ${occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] == false}`);\n    //node.warn(`user present = true?: ${presence[DATA_PATHS.USER_PRESENT] == true}`);\n    \n    return (\n        occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.AREA_ID] == DATA_PATHS.SLEEP_AREA &&  // Last occupied area = sleep area\n        occupancy[DATA_PATHS.OCCUPIED][DATA_PATHS.STATE] == false &&                    // Unoccupied (inactivity) \n        presence[DATA_PATHS.USER_PRESENT] == true                                       // User(s) present\n    );\n}\n\n/*getDelay(msg.delay, msg.timeout)\n    .then(delay => {\n        // This code will execute when the promise is resolved\n        node.warn(delay);\n        if (delay) {\n            // Set msg.delay\n            msg.delay = delay;\n            // Return details in msg for further processing if needed\n            node.send([msg, null, utils.status(`${msg.delay} milliseconds`)]);\n        }\n        else {\n            node.send([null, null, utils.status(`Missing msg.delay | env.POLL_RATE: ${msg.delay} | ${pollRate}`, { fill: \"orange\" })]);\n        }\n    })\n    .catch(error => {\n        // This code will execute when the promise is rejected\n        const status = `Error retrieving delay context: ${error.message}`;\n        node.warn(status);\n        node.send([null, null, utils.status(status, { fill: \"red\" })]);\n    });\n\nnode.send([null, msg, utils.status(`Waiting for ${msg.delay}...`, { fill: \"yellow\" })]);\n\nfunction getDelay(global_id, timeout) {\n    return utils.waitForGlobalContext(global_id, timeout)\n        .then(delay => {\n            if (delay) return delay;\n        })\n        .catch(error => {\n            // Handle any errors thrown by waitForGlobalContext\n            const status = `[ERROR]: ${error.message}`;\n            node.warn(status);\n            //node.status({ fill: \"red\", shape: \"dot\", text: status });\n            node.send([null, null, utils.status(status, { fill: \"red\" })]);\n            return null;\n        });\n}*/","outputs":2,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is started.\nnode.status({ fill: \"yellow\", shape: \"dot\", text: \"Starting\" });","finalize":"","libs":[],"x":210,"y":280,"wires":[[],[]]},{"id":"f69b3ca.3ffe7c","type":"server-state-changed","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"Occupancy Mode Updater","server":"5e6a682a.ce8468","version":5,"outputs":1,"exposeAsEntityConfig":"","entityId":"input_select.system_occupancy_mode","entityIdType":"exact","outputInitially":true,"stateType":"str","ifState":"","ifStateType":"str","ifStateOperator":"is","outputOnlyOnStateChange":true,"for":0,"forType":"num","forUnits":"minutes","ignorePrevStateNull":false,"ignorePrevStateUnknown":false,"ignorePrevStateUnavailable":false,"ignoreCurrentStateUnknown":false,"ignoreCurrentStateUnavailable":false,"outputProperties":[{"property":"payload.state","propertyType":"msg","value":"","valueType":"entityState"}],"x":550,"y":320,"wires":[["2245a9a961f6a215"]]},{"id":"ed0df5d5fb759f7b","type":"api-call-service","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"Set Occupancy Mode","server":"5e6a682a.ce8468","version":5,"debugenabled":false,"domain":"input_select","service":"select_option","areaId":[],"deviceId":[],"entityId":["input_select.system_occupancy_mode"],"data":"{\"option\":\"{{payload}}\"}","dataType":"json","mergeContext":"","mustacheAltTags":false,"outputProperties":[],"queue":"none","x":1060,"y":260,"wires":[[]]},{"id":"2245a9a961f6a215","type":"subflow:ac18d08ecf3b428c","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"","env":[{"name":"ENTITY_ID","value":"input_select.system_occupancy_mode","type":"str"}],"x":830,"y":260,"wires":[["ed0df5d5fb759f7b"]]},{"id":"1227012782df8a0e","type":"debug","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"debug 55","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":1020,"y":80,"wires":[]},{"id":"4f275fa1eca0e458","type":"change","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"Delete objects","rules":[{"t":"delete","p":"system.last_deployed","pt":"global"}],"action":"","property":"","from":"","to":"","reg":false,"x":860,"y":80,"wires":[["1227012782df8a0e"]]},{"id":"0584cedf39b8723a","type":"inject","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"DEBUG","props":[],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":710,"y":80,"wires":[["4f275fa1eca0e458"]]},{"id":"ce0d4144ed5fdf9a","type":"subflow:5c17ae8417803497","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"","env":[{"name":"GLOBAL_ID","value":"","type":"env"}],"x":570,"y":140,"wires":[[]]},{"id":"604d000ae234f177","type":"change","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"Set Global Context ID","rules":[{"t":"set","p":"global_id","pt":"msg","to":"$env(\"MODULE_ID\") & \".last_deployed\"","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":340,"y":140,"wires":[["ce0d4144ed5fdf9a"]]},{"id":"a674def38f0c9d37","type":"server-state-changed","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"Get Person(s)","server":"5e6a682a.ce8468","version":5,"outputs":1,"exposeAsEntityConfig":"","entityId":"person.","entityIdType":"substring","outputInitially":true,"stateType":"str","ifState":"","ifStateType":"str","ifStateOperator":"is","outputOnlyOnStateChange":true,"for":"0","forType":"num","forUnits":"minutes","ignorePrevStateNull":false,"ignorePrevStateUnknown":false,"ignorePrevStateUnavailable":false,"ignoreCurrentStateUnknown":false,"ignoreCurrentStateUnavailable":false,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"}],"x":130,"y":320,"wires":[["c4f79b533903359f"]]},{"id":"42a722f8accaab32","type":"server-state-changed","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"Motion Detected [ALL]","server":"5e6a682a.ce8468","version":5,"outputs":1,"exposeAsEntityConfig":"","entityId":"binary_sensor.","entityIdType":"substring","outputInitially":false,"stateType":"str","ifState":"","ifStateType":"str","ifStateOperator":"is","outputOnlyOnStateChange":true,"for":"","forType":"num","forUnits":"seconds","ignorePrevStateNull":false,"ignorePrevStateUnknown":false,"ignorePrevStateUnavailable":false,"ignoreCurrentStateUnknown":false,"ignoreCurrentStateUnavailable":false,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"eventData"}],"x":160,"y":260,"wires":[["38735b09c743921a"]]},{"id":"38735b09c743921a","type":"subflow:db47d8fece13615c","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"","x":390,"y":260,"wires":[["7d74bf6cd8138ece"]]},{"id":"c4f79b533903359f","type":"subflow:416f3e9048b97ca4","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"","x":330,"y":320,"wires":[[]]},{"id":"7d74bf6cd8138ece","type":"subflow:20b25024f4366686","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"","env":[{"name":"POLL_RATE","value":"input_number.updater_frequency","type":"str"}],"x":590,"y":260,"wires":[["2245a9a961f6a215"]]},{"id":"84d482c883a4a867","type":"subflow:2e1553480c579f63","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"","x":520,"y":200,"wires":[["4681dd71c58fc10d"]]},{"id":"a62fd577f023f24d","type":"subflow:20b25024f4366686","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"","env":[{"name":"POLL_RATE_MULTIPLIER","value":"3","type":"num"}],"x":330,"y":200,"wires":[["84d482c883a4a867"]]},{"id":"4681dd71c58fc10d","type":"function","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"Reload Registries","func":"// Reload Registries\n// Reload Areas and Entities registry files for module data classes\n// ******************************************************************\n// -*- INPUTS -*-\n// msg                          : existing msg object\n//\n// -*- OUTPUTS -*-\n// msg                          : existing msg object\n// ******************************************************************\n\n/*** START ***/\nconst system = context.global[env.get(\"MODULE_ID\")];\nconst utils = system.util.common;\nconst { Areas, Entities } = system.domain.models;\n\nlet status = utils.status(\"Registries reloaded successfully\");\n\ntry {\n    Areas.loadAreaRegistry();\n    Entities.loadEntityRegistry();\n} catch (error) {\n    status = utils.status(`[ERROR]: ${error}`, { fill: \"red\" });\n}\n\nnode.status(status.payload);\nreturn [msg, status];\n\n/*** END ***/\n\n/*** HELPERS ***/","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":730,"y":200,"wires":[["357a8217f1c72be0"]]},{"id":"322fd830eeaede98","type":"function","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"Generate Templates","func":"// Generate Templates\n// Generate Dynamic Templates for writing to file\n// ******************************************************************\n// -*- INPUTS -*-\n// msg                          : existing msg object\n//\n// -*- OUTPUTS -*-\n// msg                          : existing msg object\n// ******************************************************************\n\n/*** START ***/\nconst system = context.global[env.get(\"MODULE_ID\")];\nconst utils = system.util.common;\n\nconst TemplateGenerator = system.domain.models.template.TemplateGenerator;\n\nlet status = utils.status('Templates generated successfully');\n\ntry {\n\n    // Generate Templates\n    const templateGenerator = new TemplateGenerator();\n    msg.payload = templateGenerator.generate(system.domain.models.template, { write: true});\n\n} catch (error) {\n    status = utils.status(`[ERROR]: ${error}`, { fill: \"red\" });\n}\n\n// Set node / subflow status\nnode.status(status.payload);\nreturn [msg, status];\n\n/*** END ***/\n\n/*** HELPERS ***/","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1100,"y":200,"wires":[["c07c846829c39f05"]]},{"id":"be38cec0fa8511b4","type":"subflow:f9586397.5973","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"","x":130,"y":80,"wires":[]},{"id":"c07c846829c39f05","type":"api-call-service","z":"fe5f43f9.82396","d":true,"g":"fdedafb5b4235446","name":"Reload Packages","server":"3edfacf2.b3d2c4","version":5,"debugenabled":true,"domain":"template","service":"reload","areaId":[],"deviceId":[],"entityId":[],"data":"{}","dataType":"jsonata","mergeContext":"","mustacheAltTags":false,"outputProperties":[],"queue":"none","x":1310,"y":200,"wires":[[]]},{"id":"357a8217f1c72be0","type":"trigger","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"Send Once","op1":"","op2":"0","op1type":"pay","op2type":"str","duration":"0","extend":false,"overrideDelay":false,"units":"ms","reset":"","bytopic":"all","topic":"topic","outputs":1,"x":910,"y":200,"wires":[["322fd830eeaede98"]]},{"id":"ca4bbbd0e0a22499","type":"subflow:d4d95936d311f239","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"","env":[{"name":"PATH","value":"/config/flows.json","type":"str"}],"x":330,"y":80,"wires":[["f5fbc0ae3593a8de"]]},{"id":"f5fbc0ae3593a8de","type":"link out","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"On Deploy IN","mode":"link","links":["035ae4d8c7805872","f770e29b55017dcd"],"x":520,"y":80,"wires":[],"l":true},{"id":"035ae4d8c7805872","type":"link in","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"On Deploy OUT","links":["f5fbc0ae3593a8de"],"x":140,"y":140,"wires":[["604d000ae234f177"]],"l":true},{"id":"f770e29b55017dcd","type":"link in","z":"fe5f43f9.82396","g":"fdedafb5b4235446","name":"On Deploy OUT","links":["f5fbc0ae3593a8de"],"x":140,"y":200,"wires":[["a62fd577f023f24d"]],"l":true},{"id":"5e6a682a.ce8468","type":"server","name":"Home Assistant","version":5,"addon":true,"rejectUnauthorizedCerts":true,"ha_boolean":"y|yes|true|on|home|open","connectionDelay":true,"cacheJson":true,"heartbeat":false,"heartbeatInterval":30,"areaSelector":"friendlyName","deviceSelector":"friendlyName","entitySelector":"friendlyName","statusSeparator":"at: ","statusYear":"hidden","statusMonth":"short","statusDay":"numeric","statusHourCycle":"h23","statusTimeFormat":"h:m","enableGlobalContextStore":true}]